<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tinytroupe.agent API documentation</title>
<meta name="description" content="This module provides the main classes and functions for TinyTroupe&#39;s
agents …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tinytroupe.agent</code></h1>
</header>
<section id="section-intro">
<p>This module provides the main classes and functions for TinyTroupe's
agents.</p>
<p>Agents are the key abstraction used in TinyTroupe. An agent is a simulated person or entity that can interact with other agents and the environment, by
receiving stimuli and producing actions. Agents have cognitive states, which are updated as they interact with the environment and other agents.
Agents can also store and retrieve information from memory, and can perform actions in the environment. Different from agents whose objective is to
provide support for AI-based assistants or other such productivity tools, <strong>TinyTroupe agents aim at representing human-like behavior</strong>, which includes
idiossincracies, emotions, and other human-like traits, that one would not expect from a productivity tool.</p>
<p>The overall underlying design is inspired mainly by Cognitive Psychology, which is why agents have various internal cognitive states, such as attention, emotions, and goals.
It is also why agent memory, differently from other LLM-based agent platforms, has subtle internal divisions, notably between episodic and semantic memory.
Some behaviorist concepts are also present, such as the explicit and decoupled concepts of "stimulus" and "response" in the <code>listen</code> and <code>act</code> methods, which are key abstractions
to understand how agents interact with the environment and other agents.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides the main classes and functions for TinyTroupe&#39;s  agents.

Agents are the key abstraction used in TinyTroupe. An agent is a simulated person or entity that can interact with other agents and the environment, by
receiving stimuli and producing actions. Agents have cognitive states, which are updated as they interact with the environment and other agents. 
Agents can also store and retrieve information from memory, and can perform actions in the environment. Different from agents whose objective is to
provide support for AI-based assistants or other such productivity tools, **TinyTroupe agents aim at representing human-like behavior**, which includes
idiossincracies, emotions, and other human-like traits, that one would not expect from a productivity tool.

The overall underlying design is inspired mainly by Cognitive Psychology, which is why agents have various internal cognitive states, such as attention, emotions, and goals.
It is also why agent memory, differently from other LLM-based agent platforms, has subtle internal divisions, notably between episodic and semantic memory. 
Some behaviorist concepts are also present, such as the explicit and decoupled concepts of &#34;stimulus&#34; and &#34;response&#34; in the `listen` and `act` methods, which are key abstractions
to understand how agents interact with the environment and other agents.
&#34;&#34;&#34;

import tinytroupe.utils as utils
from pydantic import BaseModel

import logging
logger = logging.getLogger(&#34;tinytroupe&#34;)

from tinytroupe import default

###########################################################################
# Types and constants
###########################################################################
from typing import TypeVar, Union
Self = TypeVar(&#34;Self&#34;, bound=&#34;TinyPerson&#34;)
AgentOrWorld = Union[Self, &#34;TinyWorld&#34;]


###########################################################################
# Data structures to enforce output format during LLM API call.
###########################################################################
class Action(BaseModel):
    type: str
    content: str
    target: str

class CognitiveState(BaseModel):
    goals: str
    context: list[str]
    attention: str
    emotions: str

class CognitiveActionModel(BaseModel):
    action: Action
    cognitive_state: CognitiveState

class CognitiveActionModelWithReasoning(BaseModel):
    reasoning: str
    action: Action
    cognitive_state: CognitiveState


###########################################################################
# Exposed API
###########################################################################
# from. grounding ... ---&gt; not exposing this, clients should not need to know about detailed grounding mechanisms
from .memory import SemanticMemory, EpisodicMemory, EpisodicConsolidator, ReflectionConsolidator
from .mental_faculty import CustomMentalFaculty, RecallFaculty, FilesAndWebGroundingFaculty, TinyToolUse
from .tiny_person import TinyPerson

__all__ = [&#34;SemanticMemory&#34;, &#34;EpisodicMemory&#34;, &#34;EpisodicConsolidator&#34;, &#34;ReflectionConsolidator&#34;,
           &#34;CustomMentalFaculty&#34;, &#34;RecallFaculty&#34;, &#34;FilesAndWebGroundingFaculty&#34;, &#34;TinyToolUse&#34;,
           &#34;TinyPerson&#34;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="tinytroupe.agent.action_generator" href="action_generator.html">tinytroupe.agent.action_generator</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tinytroupe.agent.grounding" href="grounding.html">tinytroupe.agent.grounding</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tinytroupe.agent.memory" href="memory.html">tinytroupe.agent.memory</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tinytroupe.agent.mental_faculty" href="mental_faculty.html">tinytroupe.agent.mental_faculty</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="tinytroupe.agent.tiny_person" href="tiny_person.html">tinytroupe.agent.tiny_person</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tinytroupe.agent.CustomMentalFaculty"><code class="flex name class">
<span>class <span class="ident">CustomMentalFaculty</span></span>
<span>(</span><span>name: str, requires_faculties: list = None, actions_configs: dict = None, constraints: dict = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a custom mental faculty of an agent. Custom mental faculties are the cognitive abilities that an agent has
and that are defined by the user just by specifying the actions that the faculty can perform or the constraints that
the faculty introduces. Constraints might be related to the actions that the faculty can perform or be independent,
more general constraints that the agent must follow.</p>
<p>Initializes the custom mental faculty.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the mental faculty.</dd>
<dt><strong><code>requires_faculties</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of mental faculties that this faculty requires to function properly.
Format is ["faculty1", "faculty2", &hellip;]</dd>
<dt><strong><code>actions_configs</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with the configuration of actions that this faculty can perform.
Format is {<action_name>: {"description": <description>, "function": <function>}}</dd>
<dt><strong><code>constraints</code></strong> :&ensp;<code>dict</code></dt>
<dd>A list with the constraints introduced by this faculty.
Format is [<constraint1>, <constraint2>, &hellip;]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomMentalFaculty(TinyMentalFaculty):
    &#34;&#34;&#34;
    Represents a custom mental faculty of an agent. Custom mental faculties are the cognitive abilities that an agent has
    and that are defined by the user just by specifying the actions that the faculty can perform or the constraints that
    the faculty introduces. Constraints might be related to the actions that the faculty can perform or be independent,
    more general constraints that the agent must follow.
    &#34;&#34;&#34;

    def __init__(self, name: str, requires_faculties: list = None,
                 actions_configs: dict = None, constraints: dict = None):
        &#34;&#34;&#34;
        Initializes the custom mental faculty.

        Args:
            name (str): The name of the mental faculty.
            requires_faculties (list): A list of mental faculties that this faculty requires to function properly. 
              Format is [&#34;faculty1&#34;, &#34;faculty2&#34;, ...]
            actions_configs (dict): A dictionary with the configuration of actions that this faculty can perform.
              Format is {&lt;action_name&gt;: {&#34;description&#34;: &lt;description&gt;, &#34;function&#34;: &lt;function&gt;}}
            constraints (dict): A list with the constraints introduced by this faculty.
              Format is [&lt;constraint1&gt;, &lt;constraint2&gt;, ...]
        &#34;&#34;&#34;

        super().__init__(name, requires_faculties)

        # {&lt;action_name&gt;: {&#34;description&#34;: &lt;description&gt;, &#34;function&#34;: &lt;function&gt;}}
        if actions_configs is None:
            self.actions_configs = {}
        else:
            self.actions_configs = actions_configs
        
        # [&lt;constraint1&gt;, &lt;constraint2&gt;, ...]
        if constraints is None:
            self.constraints = {}
        else:
            self.constraints = constraints
    
    def add_action(self, action_name: str, description: str, function: Callable=None):
        self.actions_configs[action_name] = {&#34;description&#34;: description, &#34;function&#34;: function}

    def add_actions(self, actions: dict):
        for action_name, action_config in actions.items():
            self.add_action(action_name, action_config[&#39;description&#39;], action_config[&#39;function&#39;])
    
    def add_action_constraint(self, constraint: str):
        self.constraints.append(constraint)
    
    def add_actions_constraints(self, constraints: list):
        for constraint in constraints:
            self.add_action_constraint(constraint)

    def process_action(self, agent, action: dict) -&gt; bool:
        logger.debug(f&#34;Processing action: {action}&#34;)

        action_type = action[&#39;type&#39;]
        if action_type in self.actions_configs:
            action_config = self.actions_configs[action_type]
            action_function = action_config.get(&#34;function&#34;, None)

            if action_function is not None:
                action_function(agent, action)
            
            # one way or another, the action was processed
            return True 
        
        else:
            return False
    
    def actions_definitions_prompt(self) -&gt; str:
        prompt = &#34;&#34;
        for action_name, action_config in self.actions_configs.items():
            prompt += f&#34;  - {action_name.upper()}: {action_config[&#39;description&#39;]}\n&#34;
        
        return prompt

    def actions_constraints_prompt(self) -&gt; str:
        prompt = &#34;&#34;
        for constraint in self.constraints:
            prompt += f&#34;  - {constraint}\n&#34;
        
        return prompt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty">TinyMentalFaculty</a></li>
<li><a title="tinytroupe.utils.json.JsonSerializableRegistry" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry">JsonSerializableRegistry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tinytroupe.agent.CustomMentalFaculty.add_action"><code class="name flex">
<span>def <span class="ident">add_action</span></span>(<span>self, action_name: str, description: str, function: Callable = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_action(self, action_name: str, description: str, function: Callable=None):
    self.actions_configs[action_name] = {&#34;description&#34;: description, &#34;function&#34;: function}</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.CustomMentalFaculty.add_action_constraint"><code class="name flex">
<span>def <span class="ident">add_action_constraint</span></span>(<span>self, constraint: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_action_constraint(self, constraint: str):
    self.constraints.append(constraint)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.CustomMentalFaculty.add_actions"><code class="name flex">
<span>def <span class="ident">add_actions</span></span>(<span>self, actions: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_actions(self, actions: dict):
    for action_name, action_config in actions.items():
        self.add_action(action_name, action_config[&#39;description&#39;], action_config[&#39;function&#39;])</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.CustomMentalFaculty.add_actions_constraints"><code class="name flex">
<span>def <span class="ident">add_actions_constraints</span></span>(<span>self, constraints: list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_actions_constraints(self, constraints: list):
    for constraint in constraints:
        self.add_action_constraint(constraint)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty">TinyMentalFaculty</a></b></code>:
<ul class="hlist">
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_constraints_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_constraints_prompt">actions_constraints_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_definitions_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_definitions_prompt">actions_definitions_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.from_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.from_json">from_json</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.process_action" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.process_action">process_action</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.to_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tinytroupe.agent.EpisodicConsolidator"><code class="flex name class">
<span>class <span class="ident">EpisodicConsolidator</span></span>
</code></dt>
<dd>
<div class="desc"><p>Consolidates episodic memories into a more abstract representation, such as a summary or an abstract fact.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EpisodicConsolidator(MemoryProcessor):
    &#34;&#34;&#34;
    Consolidates episodic memories into a more abstract representation, such as a summary or an abstract fact.
    &#34;&#34;&#34;

    def process(self, memories: list, timestamp: str=None, context:Union[str, list, dict] = None, persona:Union[str, dict] = None, sequential: bool = True) -&gt; list:
        logger.debug(f&#34;STARTING MEMORY CONSOLIDATION: {len(memories)} memories to consolidate&#34;)

        enriched_context = f&#34;CURRENT COGNITIVE CONTEXT OF THE AGENT: {context}&#34; if context else &#34;No specific context provided for consolidation.&#34;

        result = self._consolidate(memories, timestamp, enriched_context, persona)
        logger.debug(f&#34;Consolidated {len(memories)} memories into: {result}&#34;)
        
        return result

    @utils.llm(enable_json_output_format=True, enable_justification_step=False)
    def _consolidate(self, memories: list, timestamp: str, context:str, persona:str) -&gt; dict:
        &#34;&#34;&#34;
        Given a list of input episodic memories, this method consolidates them into more organized structured representations, which however preserve all information and important details. 

        For this process, you assume:
          - This consolidation is being carried out by an agent, so the memories are from the agent&#39;s perspective. &#34;Actions&#34; refer to behaviors produced by the agent,
            while  &#34;stimulus&#34; refer to events or information from the environment or other agents that the agent has perceived.
                * Thus, in the consoldation you write &#34;I have done X&#34; or &#34;I have perceived Y&#34;, not &#34;the agent has done X&#34; or &#34;the agent has perceived Y&#34;.
          - The purpose of consolidation is to restructure and organize the most relevant information from the episodic memories, so that any facts learned therein can be used in future reasoning processes.
                * If a `context` is provided, you can use it to guide the consolidation process, making sure that the memories are consolidated in the most useful way under the given context.
                  For example, if the agent is looking for a specific type of information, you can focus the consolidation on that type of information, preserving more details about it
                  than you would otherwise.
                * If a `persona` is provided, you can use it to guide the consolidation process, making sure that the memories are consolidated in a way that is consistent with the persona.
                  For example, if the persona is that of a cat lover, you can focus the consolidation on the agent&#39;s experiences with cats, preserving more details about them than you would otherwise.
          - If the memory contians a `content` field, that&#39;s where the relevant information is found. Otherwise, consider the whole memory as relevant information.

        The consolidation process follows these rules:
          - Each consolidated memory groups together all similar entries: so actions are grouped together, stimuli go together, facts are grouped together, impressions are grouped together, 
            learned processes are grouped together, and ad-hoc elements go together too. Noise, minor details and irrelevant elements are discarded. 
            In all, you will produce at most the following consolidated entries (you can avoid some if appropriate, but not add more):
              * Actions: all actions are grouped together, giving an account of what the agent has done.
              * Stimuli: all stimuli are grouped together, giving an account of what the agent has perceived.
              * Facts: facts are extracted from the actions and stimuli, and then grouped together in a single entry, consolidating learning of objective facts.
              * Impressions: impressions, feelings, or other subjective experiences are also extracted,  and then grouped together in a single entry, consolidating subjective experiences.
              * Procedural: learned processes (e.g., how to do certain things) are also extracted, formatted in an algorithmic way (i.e., pseudo-code that is self-explanatory), and then grouped together in a 
                single entry, consolidating learned processes.
              * Ad-Hoc: important elements that do not correspond to these options are also grouped together in an ad-hoc single entry, consolidating other types of information.
          - Each consolidated memory is a comprehensive report of the relevant information from the input memories, preserving all details. The consolidation merely reorganizes the information,
            but does not remove any relevant information. The consolidated memories are not summaries, but rather a more organized and structured representation of the information in the input memories.
          

        Each input memory is a dictionary of the form:
            ```
            {
            &#34;role&#34;: role, 
            &#34;content&#34;: content, 
            &#34;type&#34;: &#34;action&#34;/&#34;stimulus&#34;/&#34;feedback&#34;/&#34;reflection&#34;, 
            &#34;simulation_timestamp&#34;: timestamp
            }
            ``` 

        Each consolidated output memory is a dictionary of the form:
            ```
            {
            &#34;content&#34;: content, 
            &#34;type&#34;: &#34;consolidated&#34;, 
            &#34;simulation_timestamp&#34;: timestamp of the consolidation
            }  
            ```


         So the final value outputed **must** be a JSON composed of a list of dictionaries, each representing a consolidated memory, **always** with the following structure:
            ```
            {&#34;consolidation&#34;:
                [
                    {
                        &#34;content&#34;: content_1, 
                        &#34;type&#34;: &#34;consolidated&#34;, 
                        &#34;simulation_timestamp&#34;: timestamp of the consolidation
                    },
                    {
                        &#34;content&#34;: content_2, 
                        &#34;type&#34;: &#34;consolidated&#34;, 
                        &#34;simulation_timestamp&#34;: timestamp of the consolidation
                    },
                    ...
                ]
            }
            ```

        Note:
          - because the output is a JSON, you must use double quotes for the keys and string values.
        ## Example (simplified)

        Here&#39;s a simplified example. Suppose the following memory contents are provided as input (simplifying here as just a bullet list of contents):
         - stimulus: &#34;I have seen a cat, walking beautifully in the street&#34;
         - stimulus: &#34;I have seen a dog, barking loudly at a passerby, looking very aggressive&#34;
         - action: &#34;I have petted the cat, run around with him (or her?), saying a thousand times how cute it is, and how much I seem to like cats&#34;
         - action: &#34;I just realized that I like cats more than dogs. For example, look at this one, it is so cute, so civilized, so noble, so elegant, an inspiring animal! I had never noted this before! &#34;
         - stimulus: &#34;The cat is meowing very loudly, it seems to be hungry&#34;
         - stimulus: &#34;Somehow a big capivara has appeared in the room, it is looking at me with curiosity&#34;

        Then, this would be a possible CORRECT output of the consolidation process (again, simplified, showing only contents in bullet list format):
          - consolidated actions: &#34;I have petted the cat, run around with it, and expressed my admiration for cats.&#34;
          - consolidated stimuli: &#34;I have seen a beautiful but hungry cat, a loud and agressive-looking dog, and - surprisingly - a capivara&#34;
          - consolidated impressions: &#34;I felt great admiration for the cat, they look like such noble and elegant animals.&#34;
          - consolidated facts: &#34;I like cats more than dogs because they are cute and noble creatures.&#34;

        These are correct because they focus on the agent&#39;s experience. In contrast, this would be an INCORRECT output of the consolidation process:
          - consolidated actions: &#34;the user sent messages about a cat, a dog and a capivara, and about playing with the cat.&#34;
          - consolidated facts: &#34;the assistant has received various messages at different times, and has performed actions in response to them.&#34;

        These are incorrect because they focus on the agent&#39;s cognition and internal implementation mechanisms, not on the agent&#39;s experience.

        Args:
            memories (list): The list of memories to consolidate.
            timestamp (str): The timestamp of the consolidation, which will be used in the consolidated memories instead of any original timestamp.
            context (str, optional): Additional context to guide the consolidation process. This can be used to provide specific instructions or constraints for the consolidation.
            persona (str, optional): The persona of the agent, which can be used to guide the consolidation process. This can be used to provide specific instructions or constraints for the consolidation.

        Returns:
            dict: A dictionary with a single key &#34;consolidation&#34;, whose value is a list of consolidated memories, each represented as a dictionary with the structure described above.
        &#34;&#34;&#34;
        # llm annotation will handle the implementation</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tinytroupe.agent.memory.MemoryProcessor" href="memory.html#tinytroupe.agent.memory.MemoryProcessor">MemoryProcessor</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tinytroupe.agent.memory.MemoryProcessor" href="memory.html#tinytroupe.agent.memory.MemoryProcessor">MemoryProcessor</a></b></code>:
<ul class="hlist">
<li><code><a title="tinytroupe.agent.memory.MemoryProcessor.process" href="memory.html#tinytroupe.agent.memory.MemoryProcessor.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tinytroupe.agent.EpisodicMemory"><code class="flex name class">
<span>class <span class="ident">EpisodicMemory</span></span>
<span>(</span><span>fixed_prefix_length: int = 20, lookback_length: int = 100)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides episodic memory capabilities to an agent. Cognitively, episodic memory is the ability to remember specific events,
or episodes, in the past. This class provides a simple implementation of episodic memory, where the agent can store and retrieve
messages from memory.</p>
<p>Subclasses of this class can be used to provide different memory implementations.</p>
<p>Initializes the memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fixed_prefix_length</code></strong> :&ensp;<code>int</code></dt>
<dd>The fixed prefix length. Defaults to 20.</dd>
<dt><strong><code>lookback_length</code></strong> :&ensp;<code>int</code></dt>
<dd>The lookback length. Defaults to 100.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EpisodicMemory(TinyMemory):
    &#34;&#34;&#34;
    Provides episodic memory capabilities to an agent. Cognitively, episodic memory is the ability to remember specific events,
    or episodes, in the past. This class provides a simple implementation of episodic memory, where the agent can store and retrieve
    messages from memory.
    
    Subclasses of this class can be used to provide different memory implementations.
    &#34;&#34;&#34;

    MEMORY_BLOCK_OMISSION_INFO = {&#39;role&#39;: &#39;assistant&#39;, &#39;content&#39;: &#34;Info: there were other messages here, but they were omitted for brevity.&#34;, &#39;simulation_timestamp&#39;: None}

    def __init__(
        self, fixed_prefix_length: int = 20, lookback_length: int = 100
    ) -&gt; None:
        &#34;&#34;&#34;
        Initializes the memory.

        Args:
            fixed_prefix_length (int): The fixed prefix length. Defaults to 20.
            lookback_length (int): The lookback length. Defaults to 100.
        &#34;&#34;&#34;
        self.fixed_prefix_length = fixed_prefix_length
        self.lookback_length = lookback_length

        # the definitive memory that records all episodic events
        self.memory = []
        
        # the current episode buffer, which is used to store messages during an episode
        self.episodic_buffer = []


    def commit_episode(self):
        &#34;&#34;&#34;
        Ends the current episode, storing the episodic buffer in memory.
        &#34;&#34;&#34;
        self.memory.extend(self.episodic_buffer)
        self.episodic_buffer = []
    
    def get_current_episode(self, item_types:list=None) -&gt; list:
        &#34;&#34;&#34;
        Returns the current episode buffer, which is used to store messages during an episode.

        Args:
            item_types (list, optional): If provided, only retrieve memories of these types. Defaults to None, which retrieves all types.

        Returns:
            list: The current episode buffer.
        &#34;&#34;&#34;
        result = copy.copy(self.episodic_buffer)
        result = self.filter_by_item_types(result, item_types) if item_types is not None else result
        return result

    def count(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of values in memory.
        &#34;&#34;&#34;
        return len(self._memory_with_current_buffer())

    def clear(self, max_prefix_to_clear:int=None, max_suffix_to_clear:int=None):
        &#34;&#34;&#34;
        Clears the memory, generating a permanent &#34;episodic amnesia&#34;. 
        If max_prefix_to_clear is not None, it clears the first n values from memory.
        If max_suffix_to_clear is not None, it clears the last n values from memory. If both are None,
        it clears all values from memory.

        Args:
            max_prefix_to_clear (int): The number of first values to clear.
            max_suffix_to_clear (int): The number of last values to clear.
        &#34;&#34;&#34;

        # clears all episodic buffer messages
        self.episodic_buffer = []

        # then clears the memory according to the parameters
        if max_prefix_to_clear is not None:
            self.memory = self.memory[max_prefix_to_clear:]

        if max_suffix_to_clear is not None:
            self.memory = self.memory[:-max_suffix_to_clear]

        if max_prefix_to_clear is None and max_suffix_to_clear is None:
            self.memory = []
    
    def _memory_with_current_buffer(self) -&gt; list:
        &#34;&#34;&#34;
        Returns the current memory, including the episodic buffer.
        This is useful for retrieving the most recent memories, including the current episode.
        &#34;&#34;&#34;
        return self.memory + self.episodic_buffer
        
    ######################################
    # General memory methods
    ######################################
    def _store(self, value: Any) -&gt; None:
        &#34;&#34;&#34;
        Stores a value in memory.
        &#34;&#34;&#34;
        self.episodic_buffer.append(value)

    def retrieve(self, first_n: int, last_n: int, include_omission_info:bool=True, item_type:str=None) -&gt; list:
        &#34;&#34;&#34;
        Retrieves the first n and/or last n values from memory. If n is None, all values are retrieved.

        Args:
            first_n (int): The number of first values to retrieve.
            last_n (int): The number of last values to retrieve.
            include_omission_info (bool): Whether to include an information message when some values are omitted.
            item_type (str, optional): If provided, only retrieve memories of this type.

        Returns:
            list: The retrieved values.
        
        &#34;&#34;&#34;

        omisssion_info = [EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO] if include_omission_info else []

        # use the other methods in the class to implement
        if first_n is not None and last_n is not None:
            return self.retrieve_first(first_n, include_omission_info=False, item_type=item_type) + omisssion_info + self.retrieve_last(last_n, include_omission_info=False, item_type=item_type)
        elif first_n is not None:
            return self.retrieve_first(first_n, include_omission_info, item_type=item_type)
        elif last_n is not None:
            return self.retrieve_last(last_n, include_omission_info, item_type=item_type)
        else:
            return self.retrieve_all(item_type=item_type)

    def retrieve_recent(self, include_omission_info:bool=True, item_type:str=None) -&gt; list:
        &#34;&#34;&#34;
        Retrieves the n most recent values from memory.

        Args:
            include_omission_info (bool): Whether to include an information message when some values are omitted.
            item_type (str, optional): If provided, only retrieve memories of this type.
        &#34;&#34;&#34;
        omisssion_info = [EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO] if include_omission_info else []
        
        # Filter memories if item_type is provided
        memories = self._memory_with_current_buffer() if item_type is None else self.filter_by_item_type(self._memory_with_current_buffer(), item_type)

        # compute fixed prefix
        fixed_prefix = memories[: self.fixed_prefix_length] + omisssion_info

        # how many lookback values remain?
        remaining_lookback = min(
            len(memories) - len(fixed_prefix) + (1 if include_omission_info else 0), self.lookback_length
        )

        # compute the remaining lookback values and return the concatenation
        if remaining_lookback &lt;= 0:
            return fixed_prefix
        else:
            return fixed_prefix + memories[-remaining_lookback:]

    def retrieve_all(self, item_type:str=None) -&gt; list:
        &#34;&#34;&#34;
        Retrieves all values from memory.

        Args:
            item_type (str, optional): If provided, only retrieve memories of this type.
        &#34;&#34;&#34;
        memories = self._memory_with_current_buffer() if item_type is None else self.filter_by_item_type(self._memory_with_current_buffer(), item_type)
        return copy.copy(memories)

    def retrieve_relevant(self, relevance_target: str, top_k:int) -&gt; list:
        &#34;&#34;&#34;
        Retrieves top-k values from memory that are most relevant to a given target.
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;Subclasses must implement this method.&#34;)

    def retrieve_first(self, n: int, include_omission_info:bool=True, item_type:str=None) -&gt; list:
        &#34;&#34;&#34;
        Retrieves the first n values from memory.

        Args:
            n (int): The number of values to retrieve.
            include_omission_info (bool): Whether to include an information message when some values are omitted.
            item_type (str, optional): If provided, only retrieve memories of this type.
        &#34;&#34;&#34;
        omisssion_info = [EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO] if include_omission_info else []
        
        memories = self._memory_with_current_buffer() if item_type is None else self.filter_by_item_type(self._memory_with_current_buffer(), item_type)
        return memories[:n] + omisssion_info
    
    def retrieve_last(self, n: int=None, include_omission_info:bool=True, item_type:str=None) -&gt; list:
        &#34;&#34;&#34;
        Retrieves the last n values from memory.

        Args:
            n (int): The number of values to retrieve, or None to retrieve all values.
            include_omission_info (bool): Whether to include an information message when some values are omitted.
            item_type (str, optional): If provided, only retrieve memories of this type.
        &#34;&#34;&#34;
        omisssion_info = [EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO] if include_omission_info else []

        memories = self._memory_with_current_buffer() if item_type is None else self.filter_by_item_type(self._memory_with_current_buffer(), item_type)
        memories = memories[-n:] if n is not None else memories
                            
        return omisssion_info + memories  </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tinytroupe.agent.memory.TinyMemory" href="memory.html#tinytroupe.agent.memory.TinyMemory">TinyMemory</a></li>
<li><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty">TinyMentalFaculty</a></li>
<li><a title="tinytroupe.utils.json.JsonSerializableRegistry" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry">JsonSerializableRegistry</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="tinytroupe.agent.EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO"><code class="name">var <span class="ident">MEMORY_BLOCK_OMISSION_INFO</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tinytroupe.agent.EpisodicMemory.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, max_prefix_to_clear: int = None, max_suffix_to_clear: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the memory, generating a permanent "episodic amnesia".
If max_prefix_to_clear is not None, it clears the first n values from memory.
If max_suffix_to_clear is not None, it clears the last n values from memory. If both are None,
it clears all values from memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>max_prefix_to_clear</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of first values to clear.</dd>
<dt><strong><code>max_suffix_to_clear</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of last values to clear.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self, max_prefix_to_clear:int=None, max_suffix_to_clear:int=None):
    &#34;&#34;&#34;
    Clears the memory, generating a permanent &#34;episodic amnesia&#34;. 
    If max_prefix_to_clear is not None, it clears the first n values from memory.
    If max_suffix_to_clear is not None, it clears the last n values from memory. If both are None,
    it clears all values from memory.

    Args:
        max_prefix_to_clear (int): The number of first values to clear.
        max_suffix_to_clear (int): The number of last values to clear.
    &#34;&#34;&#34;

    # clears all episodic buffer messages
    self.episodic_buffer = []

    # then clears the memory according to the parameters
    if max_prefix_to_clear is not None:
        self.memory = self.memory[max_prefix_to_clear:]

    if max_suffix_to_clear is not None:
        self.memory = self.memory[:-max_suffix_to_clear]

    if max_prefix_to_clear is None and max_suffix_to_clear is None:
        self.memory = []</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.EpisodicMemory.commit_episode"><code class="name flex">
<span>def <span class="ident">commit_episode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ends the current episode, storing the episodic buffer in memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit_episode(self):
    &#34;&#34;&#34;
    Ends the current episode, storing the episodic buffer in memory.
    &#34;&#34;&#34;
    self.memory.extend(self.episodic_buffer)
    self.episodic_buffer = []</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.EpisodicMemory.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of values in memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of values in memory.
    &#34;&#34;&#34;
    return len(self._memory_with_current_buffer())</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.EpisodicMemory.get_current_episode"><code class="name flex">
<span>def <span class="ident">get_current_episode</span></span>(<span>self, item_types: list = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current episode buffer, which is used to store messages during an episode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_types</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>If provided, only retrieve memories of these types. Defaults to None, which retrieves all types.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The current episode buffer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_episode(self, item_types:list=None) -&gt; list:
    &#34;&#34;&#34;
    Returns the current episode buffer, which is used to store messages during an episode.

    Args:
        item_types (list, optional): If provided, only retrieve memories of these types. Defaults to None, which retrieves all types.

    Returns:
        list: The current episode buffer.
    &#34;&#34;&#34;
    result = copy.copy(self.episodic_buffer)
    result = self.filter_by_item_types(result, item_types) if item_types is not None else result
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.EpisodicMemory.retrieve_first"><code class="name flex">
<span>def <span class="ident">retrieve_first</span></span>(<span>self, n: int, include_omission_info: bool = True, item_type: str = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the first n values from memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of values to retrieve.</dd>
<dt><strong><code>include_omission_info</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to include an information message when some values are omitted.</dd>
<dt><strong><code>item_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If provided, only retrieve memories of this type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_first(self, n: int, include_omission_info:bool=True, item_type:str=None) -&gt; list:
    &#34;&#34;&#34;
    Retrieves the first n values from memory.

    Args:
        n (int): The number of values to retrieve.
        include_omission_info (bool): Whether to include an information message when some values are omitted.
        item_type (str, optional): If provided, only retrieve memories of this type.
    &#34;&#34;&#34;
    omisssion_info = [EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO] if include_omission_info else []
    
    memories = self._memory_with_current_buffer() if item_type is None else self.filter_by_item_type(self._memory_with_current_buffer(), item_type)
    return memories[:n] + omisssion_info</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.EpisodicMemory.retrieve_last"><code class="name flex">
<span>def <span class="ident">retrieve_last</span></span>(<span>self, n: int = None, include_omission_info: bool = True, item_type: str = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the last n values from memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of values to retrieve, or None to retrieve all values.</dd>
<dt><strong><code>include_omission_info</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to include an information message when some values are omitted.</dd>
<dt><strong><code>item_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If provided, only retrieve memories of this type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_last(self, n: int=None, include_omission_info:bool=True, item_type:str=None) -&gt; list:
    &#34;&#34;&#34;
    Retrieves the last n values from memory.

    Args:
        n (int): The number of values to retrieve, or None to retrieve all values.
        include_omission_info (bool): Whether to include an information message when some values are omitted.
        item_type (str, optional): If provided, only retrieve memories of this type.
    &#34;&#34;&#34;
    omisssion_info = [EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO] if include_omission_info else []

    memories = self._memory_with_current_buffer() if item_type is None else self.filter_by_item_type(self._memory_with_current_buffer(), item_type)
    memories = memories[-n:] if n is not None else memories
                        
    return omisssion_info + memories  </code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.EpisodicMemory.retrieve_recent"><code class="name flex">
<span>def <span class="ident">retrieve_recent</span></span>(<span>self, include_omission_info: bool = True, item_type: str = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the n most recent values from memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>include_omission_info</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to include an information message when some values are omitted.</dd>
<dt><strong><code>item_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>If provided, only retrieve memories of this type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_recent(self, include_omission_info:bool=True, item_type:str=None) -&gt; list:
    &#34;&#34;&#34;
    Retrieves the n most recent values from memory.

    Args:
        include_omission_info (bool): Whether to include an information message when some values are omitted.
        item_type (str, optional): If provided, only retrieve memories of this type.
    &#34;&#34;&#34;
    omisssion_info = [EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO] if include_omission_info else []
    
    # Filter memories if item_type is provided
    memories = self._memory_with_current_buffer() if item_type is None else self.filter_by_item_type(self._memory_with_current_buffer(), item_type)

    # compute fixed prefix
    fixed_prefix = memories[: self.fixed_prefix_length] + omisssion_info

    # how many lookback values remain?
    remaining_lookback = min(
        len(memories) - len(fixed_prefix) + (1 if include_omission_info else 0), self.lookback_length
    )

    # compute the remaining lookback values and return the concatenation
    if remaining_lookback &lt;= 0:
        return fixed_prefix
    else:
        return fixed_prefix + memories[-remaining_lookback:]</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.EpisodicMemory.retrieve_relevant"><code class="name flex">
<span>def <span class="ident">retrieve_relevant</span></span>(<span>self, relevance_target: str, top_k: int) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves top-k values from memory that are most relevant to a given target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_relevant(self, relevance_target: str, top_k:int) -&gt; list:
    &#34;&#34;&#34;
    Retrieves top-k values from memory that are most relevant to a given target.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;Subclasses must implement this method.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tinytroupe.agent.memory.TinyMemory" href="memory.html#tinytroupe.agent.memory.TinyMemory">TinyMemory</a></b></code>:
<ul class="hlist">
<li><code><a title="tinytroupe.agent.memory.TinyMemory.actions_constraints_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_constraints_prompt">actions_constraints_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.actions_definitions_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_definitions_prompt">actions_definitions_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.filter_by_item_type" href="memory.html#tinytroupe.agent.memory.TinyMemory.filter_by_item_type">filter_by_item_type</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.filter_by_item_types" href="memory.html#tinytroupe.agent.memory.TinyMemory.filter_by_item_types">filter_by_item_types</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.from_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.from_json">from_json</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.process_action" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.process_action">process_action</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.retrieve" href="memory.html#tinytroupe.agent.memory.TinyMemory.retrieve">retrieve</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.retrieve_all" href="memory.html#tinytroupe.agent.memory.TinyMemory.retrieve_all">retrieve_all</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.store" href="memory.html#tinytroupe.agent.memory.TinyMemory.store">store</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.store_all" href="memory.html#tinytroupe.agent.memory.TinyMemory.store_all">store_all</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.summarize_relevant_via_full_scan" href="memory.html#tinytroupe.agent.memory.TinyMemory.summarize_relevant_via_full_scan">summarize_relevant_via_full_scan</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.to_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tinytroupe.agent.FilesAndWebGroundingFaculty"><code class="flex name class">
<span>class <span class="ident">FilesAndWebGroundingFaculty</span></span>
<span>(</span><span>folders_paths: list = None, web_urls: list = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows the agent to access local files and web pages to ground its knowledge.</p>
<p>Initializes the mental faculty.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the mental faculty.</dd>
<dt><strong><code>requires_faculties</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of mental faculties that this faculty requires to function properly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FilesAndWebGroundingFaculty(TinyMentalFaculty):
    &#34;&#34;&#34;
    Allows the agent to access local files and web pages to ground its knowledge.
    &#34;&#34;&#34;


    def __init__(self, folders_paths: list=None, web_urls: list=None):
        super().__init__(&#34;Local Files and Web Grounding&#34;)

        self.local_files_grounding_connector = LocalFilesGroundingConnector(folders_paths=folders_paths)
        self.web_grounding_connector = WebPagesGroundingConnector(web_urls=web_urls)

    def process_action(self, agent, action: dict) -&gt; bool:
        if action[&#39;type&#39;] == &#34;CONSULT&#34; and action[&#39;content&#39;] is not None:
            target_name = action[&#39;content&#39;]

            results = []
            results.append(self.local_files_grounding_connector.retrieve_by_name(target_name))
            results.append(self.web_grounding_connector.retrieve_by_name(target_name))

            if len(results) &gt; 0:
                agent.think(f&#34;I have read the following document: \n{results}&#34;)
            else:
                agent.think(f&#34;I can&#39;t find any document with the name &#39;{target_name}&#39;.&#34;)
            
            return True
        
        elif action[&#39;type&#39;] == &#34;LIST_DOCUMENTS&#34; and action[&#39;content&#39;] is not None:
            available_names = []
            available_names += self.local_files_grounding_connector.list_sources()
            available_names += self.web_grounding_connector.list_sources()

            if len(available_names) &gt; 0:
                agent.think(f&#34;I have the following documents available to me: {available_names}&#34;)
            else:
                agent.think(f&#34;I don&#39;t have any documents available for inspection.&#34;)
            
            return True

        else:
            return False


    def actions_definitions_prompt(self) -&gt; str:
        prompt = \
            &#34;&#34;&#34;
            - LIST_DOCUMENTS: you can list the names of the documents you have access to, so that you can decide which to access, if any, to accomplish your goals. Documents is a generic term and includes any 
                kind of &#34;packaged&#34; information you can access, such as emails, files, chat messages, calendar events, etc. It also includes, in particular, web pages.
                The order of in which the documents are listed is not relevant.
            - CONSULT: you can retrieve and consult a specific document, so that you can access its content and accomplish your goals. To do so, you specify the name of the document you want to consult.
            &#34;&#34;&#34;

        return textwrap.dedent(prompt)
    
    def actions_constraints_prompt(self) -&gt; str:
        prompt = \
          &#34;&#34;&#34;
            - You are aware that you have documents available to you to help in your tasks. Even if you already have knowledge about a topic, you 
              should believe that the documents can provide you with additional information that can be useful to you.
            - If you want information that might be in documents, you first LIST_DOCUMENTS to see what is available and decide if you want to access any of them.
            - You LIST_DOCUMENTS when you suspect that relevant information might be in some document, but you are not sure which one.
            - You only CONSULT the relevant documents for your present goals and context. You should **not** CONSULT documents that are not relevant to the current situation.
              You use the name of the document to determine its relevance before accessing it.
            - If you need information about a specific document, you **must** use CONSULT instead of RECALL. This is because RECALL **does not** allow you to select the specific document, and only brings small 
                relevant parts of variious documents - while CONSULT brings the precise document requested for your inspection, with its full content. 
                Example:
                ```
                LIST_DOCUMENTS
                &lt;CONSULT some document name&gt;
                &lt;THINK something about the retrieved document&gt;
                &lt;TALK something&gt;
                DONE
                ``` 
            - If you need information from specific documents, you **always** CONSULT it, **never** RECALL it.   
            - You can only CONSULT few documents before issuing DONE. 
                Example:
                ```
                &lt;CONSULT some document name&gt;
                &lt;THINK something about the retrieved document&gt;
                &lt;TALK something&gt;
                &lt;CONSULT some document name&gt;
                &lt;THINK something about the retrieved document&gt;
                &lt;TALK something&gt;
                DONE
                ```
            - When deciding whether to use RECALL or CONSULT, you should consider whether you are looking for any information about some topic (use RECALL) or if you are looking for information from
                specific documents (use CONSULT). To know if you have potentially relevant documents available, use LIST_DOCUMENTS first.
          &#34;&#34;&#34;

        return textwrap.dedent(prompt)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty">TinyMentalFaculty</a></li>
<li><a title="tinytroupe.utils.json.JsonSerializableRegistry" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry">JsonSerializableRegistry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty">TinyMentalFaculty</a></b></code>:
<ul class="hlist">
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_constraints_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_constraints_prompt">actions_constraints_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_definitions_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_definitions_prompt">actions_definitions_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.from_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.from_json">from_json</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.process_action" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.process_action">process_action</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.to_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tinytroupe.agent.RecallFaculty"><code class="flex name class">
<span>class <span class="ident">RecallFaculty</span></span>
</code></dt>
<dd>
<div class="desc"><p>Represents a mental faculty of an agent. Mental faculties are the cognitive abilities that an agent has.</p>
<p>Initializes the mental faculty.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the mental faculty.</dd>
<dt><strong><code>requires_faculties</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of mental faculties that this faculty requires to function properly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecallFaculty(TinyMentalFaculty):

    def __init__(self):
        super().__init__(&#34;Memory Recall&#34;)
        

    def process_action(self, agent, action: dict) -&gt; bool:
        logger.debug(f&#34;Processing action: {action}&#34;)

        if action[&#39;type&#39;] == &#34;RECALL&#34; and action[&#39;content&#39;] is not None:
            content = action[&#39;content&#39;]

            semantic_memories = agent.retrieve_relevant_memories(relevance_target=content)

            logger.info(f&#34;Recalling information related to &#39;{content}&#39;. Found {len(semantic_memories)} relevant memories.&#34;)

            if len(semantic_memories) &gt; 0:
                # a string with each element in the list in a new line starting with a bullet point
                agent.think(&#34;I have remembered the following information from my semantic memory and will use it to guide me in my subsequent actions: \n&#34; + \
                        &#34;\n&#34;.join([f&#34;  - {item}&#34; for item in semantic_memories]))
            else:
                agent.think(f&#34;I can&#39;t remember anything additional about &#39;{content}&#39;. I&#39;ll just use what I already currently have in mind to proceed as well as I can.&#34;)
            
            return True
        
        elif action[&#39;type&#39;] == &#34;RECALL_WITH_FULL_SCAN&#34; and action[&#39;content&#39;] is not None:
            logger.debug(f&#34;Processing RECALL_WITH_FULL_SCAN action. Recalling and summarizing information related to &#39;{action[&#39;content&#39;]}&#39; with full scan.&#34;)

            content = action[&#39;content&#39;]
            memories_summary = agent.summarize_relevant_memories_via_full_scan(relevance_target=content)

            logger.debug(f&#34;Summary produced via full scan: {memories_summary}&#34;)

            if len(memories_summary) &gt; 0:
                # the summary is presented as a block of text
                agent.think(f&#34;I have remembered the following information from my semantic memory and will use it to guide me in my subsequent actions: \n \&#34;{memories_summary}\&#34;&#34;)                        
            else:
                agent.think(f&#34;I can&#39;t remember anything additional about &#39;{content}&#39;. I&#39;ll just use what I already currently have in mind to proceed as well as I can.&#34;)

            return True
        else:
            return False

    def actions_definitions_prompt(self) -&gt; str:
        prompt = \
            &#34;&#34;&#34;
              - RECALL: you can recall information that relates to specific topics from your memory. To do, you must specify a &#34;mental query&#34; to locate the desired memory. If the memory is found, it is brought to your conscience.
              - RECALL_WITH_FULL_SCAN: you can recall information from your memory in an exhaustive way, scanning all your memories. To do, you must specify a &#34;mental query&#34; that will be used to extract the relevant information from each memory. 
                                       All the information found will be brought to your conscience. This action is more expensive than RECALL, and is meant to be used when you want to ensure that you are not missing any relevant information.
            &#34;&#34;&#34;

        return textwrap.dedent(prompt)
    
    def actions_constraints_prompt(self) -&gt; str:
        prompt = \
          &#34;&#34;&#34;
            - Before concluding you don&#39;t know something or don&#39;t have access to some information, you **must** try to RECALL or RECALL_WITH_FULL_SCAN it from your memory.
            - If you you know precisely what you are looking for, you can use RECALL to retrieve it. If you are not sure, or if you want to ensure that you are not missing any relevant information, you should use RECALL_WITH_FULL_SCAN instead.
                * RECALL example: if you want to remember &#34;what are the expected inflation rates in Brazil&#34;, you will likely use RECALL with the &#34;Brazil inflation 2024&#34; mental query, as it is likely that the appropriate memory easily matches this query.
                * RECALL_WITH_FULL_SCAN example: if you want to remember &#34;what are the pros and cons of the product&#34;, you will likely use RECALL_WITH_FULL_SCAN with a more complex mental query like &#34;Looking for: product pros and cons. Reason: the agent is performing a product evaluation&#34;, 
                  as there is probably no clear memory that matches the related keywords, and you want to ensure that you are not missing any relevant information, so you scan all your memories for this information and explain why.
            - You try to RECALL information from your memory, so that you can have more relevant elements to think and talk about, whenever such an action would be likely
                to enrich the current interaction. To do so, you must specify able &#34;mental query&#34; that is related to the things you&#39;ve been thinking, listening and talking about.
                Example:
                ```
                &lt;THINK A&gt;
                &lt;RECALL / RECALL_WITH_FULL_SCAN B, which is something related to A&gt;
                &lt;THINK about A and B&gt;
                &lt;TALK about A and B&gt;
                DONE
                ```
            - You can try to RECALL_WITH_FULL_SCAN information from your memory when you want or are tasked with finding all relevant information about a topic, and you want to ensure that you are not missing any relevant information. 
              In other words, you &#34;try hard&#34; to remember.
               Example:
                ```
                &lt;LISTEN what are the main pros and cons of the product&gt;
                &lt;RECALL_WITH_FULL_SCAN Looking for: product pros and cons. Reason: the agent is performing a product evaluation.&gt;
                &lt;THINK about all the pros and cons found&gt;
                &lt;TALK about the pros and cons recalled&gt;
                DONE
                ```
            - If you RECALL:
                * you use a &#34;mental query&#34; that describe the elements you are looking for, you do not use a question. It is like a keyword-based search query.
                For example, instead of &#34;What are the symptoms of COVID-19?&#34;, you would use &#34;COVID-19 symptoms&#34;.
                * you use keywords likely to be found in the text you are looking for. For example, instead of &#34;Brazil economic outlook&#34;, you would use &#34;Brazil economy&#34;, &#34;Brazil GPD&#34;, &#34;Brazil inflation&#34;, etc.
            - If you RECALL_WITH_FULL_SCAN:
                * you use can use many types of &#34;mental queries&#34;: describe the elements you are looking for; a specific question; or any other specification that can extract the relevant information from any given memory. It is NOT like a keyword-based search query, 
                  but instead a specification of what is important to the agent at the moment.
                * regardless of the type of &#34;mental query&#34; you use, you **also** add information about the agent&#39;s context, mainly regarding the current tasks, so that the recall mechanism can understand **why** the information is needed and can therefore 
                  retrieve the most relevant information.
                * in particular, you don&#39;t need to use keywords likely to be found in the text you are looking for, but instead focus on the precise information need that you have at the moment plus the agent&#39;s context. For example,
                  if the agent has been evaluating a product and now wants to summarize the pros and cons of the product, you can use a more complex &#34;mental query&#34; like 
                  &#34;Looking for: product pros and cons. Reason: the agent was asked to perform a product evaluation and has examined many of the product features already.&#34;.
            - It may take several tries of RECALL to get the relevant information you need. If you don&#39;t find what you are looking for, you can try again with a **very** different &#34;mental query&#34;.
                Be creative: you can use synonyms, related concepts, or any other strategy you think might help you to find the information you need. Avoid using the same terms in different queries, as it is likely to return the same results. Whenever necessary, you should retry RECALL a couple of times before giving up the location of more information.
                Example:
                ```
                &lt;THINK something&gt;
                &lt;RECALL &#34;cat products&#34;&gt;
                &lt;THINK something&gt;
                &lt;RECALL &#34;feline artifacts&#34;&gt;
                &lt;THINK something&gt;
                &lt;RECALL &#34;pet store&#34;&gt;
                &lt;THINK something&gt;
                &lt;TALK something&gt;
                DONE
                ```
            - If you did not find what you needed using RECALL after a few attempts, you can try RECALL_WITH_FULL_SCAN instead.
            - You **may** interleave THINK and RECALL / RECALL_WITH_FULL_SCAN so that you can better reflect on the information you are trying to recall.
            - If you need information about a specific document, you **must** use CONSULT instead of RECALL / RECALL_WITH_FULL_SCAN. This is because RECALL / RECALL_WITH_FULL_SCAN **does not** allow you to select the specific document, and only brings small 
                relevant parts of variious documents - while CONSULT brings the precise document requested for your inspection, with its full content. 
                Example:
                ```
                LIST_DOCUMENTS
                &lt;CONSULT some document name&gt;
                &lt;THINK something about the retrieved document&gt;
                &lt;TALK something&gt;
                DONE
                ``` 
          &#34;&#34;&#34;

        return textwrap.dedent(prompt)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty">TinyMentalFaculty</a></li>
<li><a title="tinytroupe.utils.json.JsonSerializableRegistry" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry">JsonSerializableRegistry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty">TinyMentalFaculty</a></b></code>:
<ul class="hlist">
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_constraints_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_constraints_prompt">actions_constraints_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_definitions_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_definitions_prompt">actions_definitions_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.from_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.from_json">from_json</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.process_action" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.process_action">process_action</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.to_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tinytroupe.agent.ReflectionConsolidator"><code class="flex name class">
<span>class <span class="ident">ReflectionConsolidator</span></span>
</code></dt>
<dd>
<div class="desc"><p>Memory reflection mechanism.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReflectionConsolidator(MemoryProcessor):
    &#34;&#34;&#34;
    Memory reflection mechanism.
    &#34;&#34;&#34;

    def process(self, memories: list, timestamp: str=None, context:Union[str, list, dict] = None, persona:Union[str, dict] = None, sequential: bool = True) -&gt; list:
        return self._reflect(memories, timestamp)

    def _reflect(self, memories: list, timestamp: str) -&gt; list:
        &#34;&#34;&#34;
        Given a list of input episodic memories, this method reflects on them and produces a more abstract representation, such as a summary or an abstract fact.
        The reflection process follows these rules:
          - Objective facts or knowledge that are present in the set of memories are grouped together, abstracted (if necessary) and summarized. The aim is to
            produce a semantic memory.
          - Impressions, feelings, or other subjective experiences are summarized into a more abstract representation, such as a summary or an abstract subjective fact.
          - Timestamps in the consolidated memories refer to the moment of the reflection, not to the source events that produced the original episodic memories.
          - No episodic memory is generated, all memories are consolidated as more abstract semantic memories.
          - In general, the reflection process aims to reduce the number of memories while preserving the most relevant information and removing redundant or less relevant information.
        &#34;&#34;&#34;
        pass # TODO
    def _reflect(self, memories: list, timestamp: str) -&gt; list:
        &#34;&#34;&#34;
        Given a list of input episodic memories, this method reflects on them and produces a more abstract representation, such as a summary or an abstract fact.
        The reflection process follows these rules:
          - Objective facts or knowledge that are present in the set of memories are grouped together, abstracted (if necessary) and summarized. The aim is to
            produce a semantic memory.
          - Impressions, feelings, or other subjective experiences are summarized into a more abstract representation, such as a summary or an abstract subjective fact.
          - Timestamps in the consolidated memories refer to the moment of the reflection, not to the source events that produced the original episodic memories.
          - No episodic memory is generated, all memories are consolidated as more abstract semantic memories.
          - In general, the reflection process aims to reduce the number of memories while preserving the most relevant information and removing redundant or less relevant information.
        &#34;&#34;&#34;
        pass # TODO</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tinytroupe.agent.memory.MemoryProcessor" href="memory.html#tinytroupe.agent.memory.MemoryProcessor">MemoryProcessor</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tinytroupe.agent.memory.MemoryProcessor" href="memory.html#tinytroupe.agent.memory.MemoryProcessor">MemoryProcessor</a></b></code>:
<ul class="hlist">
<li><code><a title="tinytroupe.agent.memory.MemoryProcessor.process" href="memory.html#tinytroupe.agent.memory.MemoryProcessor.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tinytroupe.agent.SemanticMemory"><code class="flex name class">
<span>class <span class="ident">SemanticMemory</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>In Cognitive Psychology, semantic memory is the memory of meanings, understandings, and other concept-based knowledge unrelated to specific
experiences. It is not ordered temporally, and it is not about remembering specific events or episodes. This class provides a simple implementation
of semantic memory, where the agent can store and retrieve semantic information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@utils.post_init
class SemanticMemory(TinyMemory):
    &#34;&#34;&#34;
    In Cognitive Psychology, semantic memory is the memory of meanings, understandings, and other concept-based knowledge unrelated to specific 
    experiences. It is not ordered temporally, and it is not about remembering specific events or episodes. This class provides a simple implementation
    of semantic memory, where the agent can store and retrieve semantic information.
    &#34;&#34;&#34;

    serializable_attributes = [&#34;memories&#34;, &#34;semantic_grounding_connector&#34;]

    def __init__(self, memories: list=None) -&gt; None:
        self.memories = memories
       
        self.semantic_grounding_connector = None

        # @post_init ensures that _post_init is called after the __init__ method

    def _post_init(self): 
        &#34;&#34;&#34;
        This will run after __init__, since the class has the @post_init decorator.
        It is convenient to separate some of the initialization processes to make deserialize easier.
        &#34;&#34;&#34;

        if not hasattr(self, &#39;memories&#39;) or self.memories is None:
            self.memories = []

        if not hasattr(self, &#39;semantic_grounding_connector&#39;) or self.semantic_grounding_connector is None:
            self.semantic_grounding_connector = BaseSemanticGroundingConnector(&#34;Semantic Memory Storage&#34;)
            
            # TODO remove?
            #self.semantic_grounding_connector.add_documents(self._build_documents_from(self.memories))
    
        
    def _preprocess_value_for_storage(self, value: dict) -&gt; Any:
        logger.debug(f&#34;Preprocessing value for storage: {value}&#34;)

        if isinstance(value, dict):
            engram = {&#34;role&#34;: &#34;assistant&#34;,
                    &#34;content&#34;: value[&#39;content&#39;],
                    &#34;type&#34;: value.get(&#34;type&#34;, &#34;information&#34;),  # Default to &#39;information&#39; if type is not specified
                    &#34;simulation_timestamp&#34;: value.get(&#34;simulation_timestamp&#34;, None)}

            # Refine the content of the engram is built based on the type of the value to make it more meaningful.
            if value[&#39;type&#39;] == &#39;action&#39;:
                engram[&#39;content&#39;] = f&#34;# Action performed\n&#34; +\
                        f&#34;I have performed the following action at date and time {value[&#39;simulation_timestamp&#39;]}:\n\n&#34;+\
                        f&#34; {value[&#39;content&#39;]}&#34;
            
            elif value[&#39;type&#39;] == &#39;stimulus&#39;:
                engram[&#39;content&#39;] = f&#34;# Stimulus\n&#34; +\
                        f&#34;I have received the following stimulus at date and time {value[&#39;simulation_timestamp&#39;]}:\n\n&#34;+\
                        f&#34; {value[&#39;content&#39;]}&#34;
            elif value[&#39;type&#39;] == &#39;feedback&#39;:
                engram[&#39;content&#39;] = f&#34;# Feedback\n&#34; +\
                        f&#34;I have received the following feedback at date and time {value[&#39;simulation_timestamp&#39;]}:\n\n&#34;+\
                        f&#34; {value[&#39;content&#39;]}&#34;
            elif value[&#39;type&#39;] == &#39;consolidated&#39;:
                engram[&#39;content&#39;] = f&#34;# Consolidated Memory\n&#34; +\
                        f&#34;I have consolidated the following memory at date and time {value[&#39;simulation_timestamp&#39;]}:\n\n&#34;+\
                        f&#34; {value[&#39;content&#39;]}&#34;
            elif value[&#39;type&#39;] == &#39;reflection&#39;:
                engram[&#39;content&#39;] = f&#34;# Reflection\n&#34; +\
                        f&#34;I have reflected on the following memory at date and time {value[&#39;simulation_timestamp&#39;]}:\n\n&#34;+\
                        f&#34; {value[&#39;content&#39;]}&#34;
            else:
                engram[&#39;content&#39;] = f&#34;# Information\n&#34; +\
                        f&#34;I have obtained following information at date and time {value[&#39;simulation_timestamp&#39;]}:\n\n&#34;+\
                        f&#34; {value[&#39;content&#39;]}&#34;

            # else: # Anything else here?
            
        else:
            # If the value is not a dictionary, we just store it as is, but we still wrap it in an engram
            engram = {&#34;role&#34;: &#34;assistant&#34;,
                    &#34;content&#34;: value,
                    &#34;type&#34;: &#34;information&#34;,  # Default to &#39;information&#39; if type is not specified
                    &#34;simulation_timestamp&#34;: None}

        logger.debug(f&#34;Engram created for storage: {engram}&#34;)

        return engram

    def _store(self, value: Any) -&gt; None:
        logger.debug(f&#34;Preparing engram for semantic memory storage, input value: {value}&#34;)
        self.memories.append(value)  # Store the value in the local memory list

        # then econduct the value to a Document and store it in the semantic grounding connector
        # This is the actual storage in the semantic memory to allow semantic retrieval
        engram_doc = self._build_document_from(value)
        logger.debug(f&#34;Storing engram in semantic memory: {engram_doc}&#34;)
        self.semantic_grounding_connector.add_document(engram_doc)
    
    def retrieve_relevant(self, relevance_target:str, top_k=20) -&gt; list:
        &#34;&#34;&#34;
        Retrieves all values from memory that are relevant to a given target.
        &#34;&#34;&#34;
        return self.semantic_grounding_connector.retrieve_relevant(relevance_target, top_k)

    def retrieve_all(self, item_type:str=None) -&gt; list:
        &#34;&#34;&#34;
        Retrieves all values from memory.

        Args:
            item_type (str, optional): If provided, only retrieve memories of this type.
        &#34;&#34;&#34;

        memories = []

        logger.debug(f&#34;Retrieving all documents from semantic memory connector, a total of {len(self.semantic_grounding_connector.documents)} documents.&#34;)
        for document in self.semantic_grounding_connector.documents:
            logger.debug(f&#34;Retrieving document from semantic memory: {document}&#34;)
            memory_text = document.text
            logger.debug(f&#34;Document text retrieved: {memory_text}&#34;)

            try:
                memory = json.loads(memory_text)
                logger.debug(f&#34;Memory retrieved: {memory}&#34;)
                memories.append(memory)                

            except json.JSONDecodeError as e:
                logger.warning(f&#34;Could not decode memory from document text: {memory_text}. Error: {e}&#34;)

        if item_type is not None:
            memories = self.filter_by_item_type(memories, item_type)
        
        return memories
    
    #####################################
    # Auxiliary compatibility methods
    #####################################

    def _build_document_from(self, memory) -&gt; Document:
        # TODO: add any metadata as well?
        
        # make sure we are dealing with a dictionary
        if not isinstance(memory, dict):
            memory = {&#34;content&#34;: memory, &#34;type&#34;: &#34;information&#34;}

        # ensures double quotes are used for JSON serialization, and maybe other formatting details
        memory_txt = json.dumps(memory, ensure_ascii=False)
        logger.debug(f&#34;Building document from memory: {memory_txt}&#34;)
        
        return Document(text=memory_txt)

    def _build_documents_from(self, memories: list) -&gt; list:
        return [self._build_document_from(memory) for memory in memories]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tinytroupe.agent.memory.TinyMemory" href="memory.html#tinytroupe.agent.memory.TinyMemory">TinyMemory</a></li>
<li><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty">TinyMentalFaculty</a></li>
<li><a title="tinytroupe.utils.json.JsonSerializableRegistry" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry">JsonSerializableRegistry</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="tinytroupe.agent.SemanticMemory.serializable_attributes"><code class="name">var <span class="ident">serializable_attributes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tinytroupe.agent.memory.TinyMemory" href="memory.html#tinytroupe.agent.memory.TinyMemory">TinyMemory</a></b></code>:
<ul class="hlist">
<li><code><a title="tinytroupe.agent.memory.TinyMemory.actions_constraints_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_constraints_prompt">actions_constraints_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.actions_definitions_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_definitions_prompt">actions_definitions_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.filter_by_item_type" href="memory.html#tinytroupe.agent.memory.TinyMemory.filter_by_item_type">filter_by_item_type</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.filter_by_item_types" href="memory.html#tinytroupe.agent.memory.TinyMemory.filter_by_item_types">filter_by_item_types</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.from_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.from_json">from_json</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.process_action" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.process_action">process_action</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.retrieve" href="memory.html#tinytroupe.agent.memory.TinyMemory.retrieve">retrieve</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.retrieve_all" href="memory.html#tinytroupe.agent.memory.TinyMemory.retrieve_all">retrieve_all</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.retrieve_recent" href="memory.html#tinytroupe.agent.memory.TinyMemory.retrieve_recent">retrieve_recent</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.retrieve_relevant" href="memory.html#tinytroupe.agent.memory.TinyMemory.retrieve_relevant">retrieve_relevant</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.store" href="memory.html#tinytroupe.agent.memory.TinyMemory.store">store</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.store_all" href="memory.html#tinytroupe.agent.memory.TinyMemory.store_all">store_all</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.summarize_relevant_via_full_scan" href="memory.html#tinytroupe.agent.memory.TinyMemory.summarize_relevant_via_full_scan">summarize_relevant_via_full_scan</a></code></li>
<li><code><a title="tinytroupe.agent.memory.TinyMemory.to_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tinytroupe.agent.TinyPerson"><code class="flex name class">
<span>class <span class="ident">TinyPerson</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A simulated person in the TinyTroupe universe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@utils.post_init
class TinyPerson(JsonSerializableRegistry):
    &#34;&#34;&#34;A simulated person in the TinyTroupe universe.&#34;&#34;&#34;

    # The maximum number of actions that an agent is allowed to perform before DONE.
    # This prevents the agent from acting without ever stopping.
    MAX_ACTIONS_BEFORE_DONE = 15

    # The maximum similarity between consecutive actions. If the similarity is too high, the action is discarded and replaced by a DONE.
    # Set this to None to disable the check.
    MAX_ACTION_SIMILARITY = 0.85

    MIN_EPISODE_LENGTH = config_manager.get(&#34;min_episode_length&#34;, 15)  # The minimum number of messages in an episode before it is considered valid.
    MAX_EPISODE_LENGTH = config_manager.get(&#34;max_episode_length&#34;, 50)  # The maximum number of messages in an episode before it is considered valid.

    PP_TEXT_WIDTH = 100

    serializable_attributes = [&#34;_persona&#34;, &#34;_mental_state&#34;, &#34;_mental_faculties&#34;, &#34;_current_episode_event_count&#34;, &#34;episodic_memory&#34;, &#34;semantic_memory&#34;]
    serializable_attributes_renaming = {&#34;_mental_faculties&#34;: &#34;mental_faculties&#34;, &#34;_persona&#34;: &#34;persona&#34;, &#34;_mental_state&#34;: &#34;mental_state&#34;, &#34;_current_episode_event_count&#34;: &#34;current_episode_event_count&#34;}

    # A dict of all agents instantiated so far.
    all_agents = {}  # name -&gt; agent
   
    # Whether to display the communication or not. True is for interactive applications, when we want to see simulation
    # outputs as they are produced.
    communication_display:bool=True
    

    def __init__(self, name:str=None, 
                 action_generator=None,
                 episodic_memory=None,
                 semantic_memory=None,
                 mental_faculties:list=None,
                 enable_basic_action_repetition_prevention:bool=True):
        &#34;&#34;&#34;
        Creates a TinyPerson.

        Args:
            name (str): The name of the TinyPerson. Either this or spec_path must be specified.
            action_generator (ActionGenerator, optional): The action generator to use. Defaults to ActionGenerator().
            episodic_memory (EpisodicMemory, optional): The memory implementation to use. Defaults to EpisodicMemory().
            semantic_memory (SemanticMemory, optional): The memory implementation to use. Defaults to SemanticMemory().
            mental_faculties (list, optional): A list of mental faculties to add to the agent. Defaults to None.
            enable_basic_action_repetition_prevention (bool, optional): Whether to enable basic action repetition prevention. Defaults to True.
        &#34;&#34;&#34;

        # NOTE: default values will be given in the _post_init method, as that&#39;s shared by 
        #       direct initialization as well as via deserialization.

        if action_generator is not None:
            self.action_generator = action_generator

        if episodic_memory is not None:
            self.episodic_memory = episodic_memory
        
        if semantic_memory is not None:
            self.semantic_memory = semantic_memory

        # Mental faculties
        if mental_faculties is not None:
            self._mental_faculties = mental_faculties
        
        if enable_basic_action_repetition_prevention:
            self.enable_basic_action_repetition_prevention = enable_basic_action_repetition_prevention
        
        assert name is not None, &#34;A TinyPerson must have a name.&#34;
        self.name = name

        # @post_init makes sure that _post_init is called after __init__

    
    def _post_init(self, **kwargs):
        &#34;&#34;&#34;
        This will run after __init__, since the class has the @post_init decorator.
        It is convenient to separate some of the initialization processes to make deserialize easier.
        &#34;&#34;&#34;

        from tinytroupe.agent.action_generator import ActionGenerator # import here to avoid circular import issues


        ############################################################
        # Default values
        ############################################################

        self.current_messages = []
        
        # the current environment in which the agent is acting
        self.environment = None

        # The list of actions that this agent has performed so far, but which have not been
        # consumed by the environment yet.
        self._actions_buffer = []

        # The list of agents that this agent can currently interact with.
        # This can change over time, as agents move around the world.
        self._accessible_agents = []

        # the buffer of communications that have been displayed so far, used for
        # saving these communications to another output form later (e.g., caching)
        self._displayed_communications_buffer = []

        if not hasattr(self, &#39;_current_episode_event_count&#39;):
            self._current_episode_event_count = 0  # the number of events in the current episode, used to limit the episode length

        if not hasattr(self, &#39;action_generator&#39;):
            # This default value MUST NOT be in the method signature, otherwise it will be shared across all instances.
            self.action_generator = ActionGenerator(max_attempts=config_manager.get(&#34;action_generator_max_attempts&#34;),
                                                    enable_quality_checks=config_manager.get(&#34;action_generator_enable_quality_checks&#34;),
                                                    enable_regeneration=config_manager.get(&#34;action_generator_enable_regeneration&#34;),
                                                    enable_direct_correction=config_manager.get(&#34;action_generator_enable_direct_correction&#34;),
                                                    enable_quality_check_for_persona_adherence=config_manager.get(&#34;action_generator_enable_quality_check_for_persona_adherence&#34;),
                                                    enable_quality_check_for_selfconsistency=config_manager.get(&#34;action_generator_enable_quality_check_for_selfconsistency&#34;),
                                                    enable_quality_check_for_fluency=config_manager.get(&#34;action_generator_enable_quality_check_for_fluency&#34;),
                                                    enable_quality_check_for_suitability=config_manager.get(&#34;action_generator_enable_quality_check_for_suitability&#34;),
                                                    enable_quality_check_for_similarity=config_manager.get(&#34;action_generator_enable_quality_check_for_similarity&#34;),
                                                    continue_on_failure=config_manager.get(&#34;action_generator_continue_on_failure&#34;),
                                                    quality_threshold=config_manager.get(&#34;action_generator_quality_threshold&#34;))

        if not hasattr(self, &#39;episodic_memory&#39;):
            # This default value MUST NOT be in the method signature, otherwise it will be shared across all instances.
            self.episodic_memory = EpisodicMemory(fixed_prefix_length= config_manager.get(&#34;episodic_memory_fixed_prefix_length&#34;),
                                                   lookback_length=config_manager.get(&#34;episodic_memory_lookback_length&#34;))
        
        if not hasattr(self, &#39;semantic_memory&#39;):
            # This default value MUST NOT be in the method signature, otherwise it will be shared across all instances.
            self.semantic_memory = SemanticMemory()
        
        # _mental_faculties
        if not hasattr(self, &#39;_mental_faculties&#39;):
            # This default value MUST NOT be in the method signature, otherwise it will be shared across all instances.
            self._mental_faculties = []
        
        # basic action repetition prevention
        if not hasattr(self, &#39;enable_basic_action_repetition_prevention&#39;):
            self.enable_basic_action_repetition_prevention = True

        # create the persona configuration dictionary
        if not hasattr(self, &#39;_persona&#39;):          
            self._persona = {
                &#34;name&#34;: self.name,
                &#34;age&#34;: None,
                &#34;nationality&#34;: None,
                &#34;country_of_residence&#34;: None,
                &#34;occupation&#34;: None
            }
        
        if not hasattr(self, &#39;name&#39;): 
            self.name = self._persona[&#34;name&#34;]

        # create the mental state dictionary
        if not hasattr(self, &#39;_mental_state&#39;):
            self._mental_state = {
                &#34;datetime&#34;: None,
                &#34;location&#34;: None,
                &#34;context&#34;: [],
                &#34;goals&#34;: [],
                &#34;attention&#34;: None,
                &#34;emotions&#34;: &#34;Feeling nothing in particular, just calm.&#34;,
                &#34;memory_context&#34;: None,
                &#34;accessible_agents&#34;: []  # [{&#34;agent&#34;: agent_1, &#34;relation&#34;: &#34;My friend&#34;}, {&#34;agent&#34;: agent_2, &#34;relation&#34;: &#34;My colleague&#34;}, ...]
            }
        
        if not hasattr(self, &#39;_extended_agent_summary&#39;):
            self._extended_agent_summary = None
        
        if not hasattr(self, &#39;actions_count&#39;):
            self.actions_count = 0
        
        if not hasattr(self, &#39;stimuli_count&#39;):
            self.stimuli_count = 0

        self._prompt_template_path = os.path.join(
            os.path.dirname(__file__), &#34;prompts/tiny_person.mustache&#34;
        )
        self._init_system_message = None  # initialized later


        ############################################################
        # Special mechanisms used during deserialization
        ############################################################

        # rename agent to some specific name?
        if kwargs.get(&#34;new_agent_name&#34;) is not None:
            self._rename(kwargs.get(&#34;new_agent_name&#34;))
        
        # If auto-rename, use the given name plus some new number ...
        if kwargs.get(&#34;auto_rename&#34;) is True:
            new_name = self.name # start with the current name
            rename_succeeded = False
            while not rename_succeeded:
                try:
                    self._rename(new_name)
                    TinyPerson.add_agent(self)
                    rename_succeeded = True                
                except ValueError:
                    new_id = utils.fresh_id(self.__class__.__name__)
                    new_name = f&#34;{self.name}_{new_id}&#34;
        
        # ... otherwise, just register the agent
        else:
            # register the agent in the global list of agents
            TinyPerson.add_agent(self)

        # start with a clean slate
        self.reset_prompt()

        # it could be the case that the agent is being created within a simulation scope, in which case
        # the simulation_id must be set accordingly
        if current_simulation() is not None:
            current_simulation().add_agent(self)
        else:
            self.simulation_id = None
    
    def _rename(self, new_name:str):    
        self.name = new_name
        self._persona[&#34;name&#34;] = self.name


    def generate_agent_system_prompt(self):
        with open(self._prompt_template_path, &#34;r&#34;) as f:
            agent_prompt_template = f.read()

        # let&#39;s operate on top of a copy of the configuration, because we&#39;ll need to add more variables, etc.
        template_variables = self._persona.copy()    
        template_variables[&#34;persona&#34;] = json.dumps(self._persona.copy(), indent=4)    

        # add mental state to the template variables
        template_variables[&#34;mental_state&#34;] = json.dumps(self._mental_state, indent=4)

        # Prepare additional action definitions and constraints
        actions_definitions_prompt = &#34;&#34;
        actions_constraints_prompt = &#34;&#34;
        for faculty in self._mental_faculties:
            actions_definitions_prompt += f&#34;{faculty.actions_definitions_prompt()}\n&#34;
            actions_constraints_prompt += f&#34;{faculty.actions_constraints_prompt()}\n&#34;
        
        # Make the additional prompt pieces available to the template. 
        # Identation here is to align with the text structure in the template.
        template_variables[&#39;actions_definitions_prompt&#39;] = textwrap.indent(actions_definitions_prompt.strip(), &#34;  &#34;)
        template_variables[&#39;actions_constraints_prompt&#39;] = textwrap.indent(actions_constraints_prompt.strip(), &#34;  &#34;)

        # RAI prompt components, if requested
        template_variables = utils.add_rai_template_variables_if_enabled(template_variables)

        return chevron.render(agent_prompt_template, template_variables)

    def reset_prompt(self):

        # render the template with the current configuration
        self._init_system_message = self.generate_agent_system_prompt()

        # - reset system message
        # - make it clear that the provided events are past events and have already had their effects
        self.current_messages = [
            {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: self._init_system_message},
            {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: &#34;The next messages refer to past interactions you had recently and are meant to help you contextualize your next actions. &#34;\
                                        + &#34;They are the most recent episodic memories you have, including stimuli and actions. &#34;\
                                        + &#34;Their effects already took place and led to your present cognitive state (described above), so you can use them in conjunction &#34;\
                                        + &#34;with your cognitive state to inform your next actions and perceptions. Please consider them and then proceed with your next actions right after. &#34;}
        ]

        # sets up the actual interaction messages to use for prompting
        self.current_messages += self.retrieve_recent_memories()


    #########################################################################
    # Persona definitions
    #########################################################################
    
    # 
    # Conveniences to access the persona configuration via dictionary-like syntax using
    # the [] operator. e.g., agent[&#34;nationality&#34;] = &#34;American&#34;
    #
    def __getitem__(self, key):
        return self.get(key)

    def __setitem__(self, key, value):
        self.define(key, value)

    #
    # Conveniences to import persona definitions via the &#39;+&#39; operator, 
    #  e.g., agent + {&#34;nationality&#34;: &#34;American&#34;, ...}
    #
    #  e.g., agent + &#34;path/to/fragment.json&#34;
    #
    def __add__(self, other):
        &#34;&#34;&#34;
        Allows using the &#39;+&#39; operator to add persona definitions or import a fragment.
        If &#39;other&#39; is a dict, calls include_persona_definitions().
        If &#39;other&#39; is a string, calls import_fragment().
        &#34;&#34;&#34;
        if isinstance(other, dict):
            self.include_persona_definitions(other)
        elif isinstance(other, str):
            self.import_fragment(other)
        else:
            raise TypeError(&#34;Unsupported operand type for +. Must be a dict or a string path to fragment.&#34;)
        return self

    #
    # Various other conveniences to manipulate the persona configuration
    #

    def get(self, key):
        &#34;&#34;&#34;
        Returns the value of a key in the TinyPerson&#39;s persona configuration.
        Supports dot notation for nested keys (e.g., &#34;address.city&#34;).
        &#34;&#34;&#34;
        keys = key.split(&#34;.&#34;)
        value = self._persona
        for k in keys:
            if isinstance(value, dict):
                value = value.get(k, None)
            else:
                return None  # If the path is invalid, return None
        return value
    
    @transactional()
    def import_fragment(self, path):
        &#34;&#34;&#34;
        Imports a fragment of a persona configuration from a JSON file.
        &#34;&#34;&#34;
        with open(path, &#34;r&#34;) as f:
            fragment = json.load(f)

        # check the type is &#34;Fragment&#34; and that there&#39;s also a &#34;persona&#34; key
        if fragment.get(&#34;type&#34;, None) == &#34;Fragment&#34; and fragment.get(&#34;persona&#34;, None) is not None:
            self.include_persona_definitions(fragment[&#34;persona&#34;])
        else:
            raise ValueError(&#34;The imported JSON file must be a valid fragment of a persona configuration.&#34;)
        
        # must reset prompt after adding to configuration
        self.reset_prompt()

    @transactional()
    def include_persona_definitions(self, additional_definitions: dict):
        &#34;&#34;&#34;
        Imports a set of definitions into the TinyPerson. They will be merged with the current configuration.
        It is also a convenient way to include multiple bundled definitions into the agent.

        Args:
            additional_definitions (dict): The additional definitions to import.
        &#34;&#34;&#34;

        self._persona = utils.merge_dicts(self._persona, additional_definitions)

        # must reset prompt after adding to configuration
        self.reset_prompt()
        
    
    @transactional()
    def define(self, key, value, merge=False, overwrite_scalars=True):
        &#34;&#34;&#34;
        Define a value to the TinyPerson&#39;s persona configuration. Value can either be a scalar or a dictionary.
        If the value is a dictionary or list, you can choose to merge it with the existing value or replace it. 
        If the value is a scalar, you can choose to overwrite the existing value or not.

        Args:
            key (str): The key to define.
            value (Any): The value to define.
            merge (bool, optional): Whether to merge the dict/list values with the existing values or replace them. Defaults to False.
            overwrite_scalars (bool, optional): Whether to overwrite scalar values or not. Defaults to True.
        &#34;&#34;&#34;

        # dedent value if it is a string
        if isinstance(value, str):
            value = textwrap.dedent(value)

        # if the value is a dictionary, we can choose to merge it with the existing value or replace it
        if isinstance(value, dict) or isinstance(value, list):
            if merge:
                self._persona = utils.merge_dicts(self._persona, {key: value})
            else:
                self._persona[key] = value

        # if the value is a scalar, we can choose to overwrite it or not
        elif overwrite_scalars or (key not in self._persona):
            self._persona[key] = value
        
        else:
            raise ValueError(f&#34;The key &#39;{key}&#39; already exists in the persona configuration and overwrite_scalars is set to False.&#34;)

            
        # must reset prompt after adding to configuration
        self.reset_prompt()

    
    @transactional()
    def define_relationships(self, relationships, replace=True):
        &#34;&#34;&#34;
        Defines or updates the TinyPerson&#39;s relationships.

        Args:
            relationships (list or dict): The relationships to add or replace. Either a list of dicts mapping agent names to relationship descriptions,
              or a single dict mapping one agent name to its relationship description.
            replace (bool, optional): Whether to replace the current relationships or just add to them. Defaults to True.
        &#34;&#34;&#34;
        
        if (replace == True) and (isinstance(relationships, list)):
            self._persona[&#39;relationships&#39;] = relationships

        elif replace == False:
            current_relationships = self._persona[&#39;relationships&#39;]
            if isinstance(relationships, list):
                for r in relationships:
                    current_relationships.append(r)
                
            elif isinstance(relationships, dict) and len(relationships) == 2: #{&#34;Name&#34;: ..., &#34;Description&#34;: ...}
                current_relationships.append(relationships)

            else:
                raise Exception(&#34;Only one key-value pair is allowed in the relationships dict.&#34;)

        else:
            raise Exception(&#34;Invalid arguments for define_relationships.&#34;)

    ##############################################################################
    # Relationships
    ##############################################################################

    @transactional()
    def clear_relationships(self):
        &#34;&#34;&#34;
        Clears the TinyPerson&#39;s relationships.
        &#34;&#34;&#34;
        self._persona[&#39;relationships&#39;] = []  

        return self      
    
    @transactional()
    def related_to(self, other_agent, description, symmetric_description=None):
        &#34;&#34;&#34;
        Defines a relationship between this agent and another agent.

        Args:
            other_agent (TinyPerson): The other agent.
            description (str): The description of the relationship.
            symmetric (bool): Whether the relationship is symmetric or not. That is, 
              if the relationship is defined for both agents.
        
        Returns:
            TinyPerson: The agent itself, to facilitate chaining.
        &#34;&#34;&#34;
        self.define_relationships([{&#34;Name&#34;: other_agent.name, &#34;Description&#34;: description}], replace=False)
        if symmetric_description is not None:
            other_agent.define_relationships([{&#34;Name&#34;: self.name, &#34;Description&#34;: symmetric_description}], replace=False)
        
        return self
    
    ############################################################################
    
    def add_mental_faculties(self, mental_faculties):
        &#34;&#34;&#34;
        Adds a list of mental faculties to the agent.
        &#34;&#34;&#34;
        for faculty in mental_faculties:
            self.add_mental_faculty(faculty)
        
        return self

    def add_mental_faculty(self, faculty):
        &#34;&#34;&#34;
        Adds a mental faculty to the agent.
        &#34;&#34;&#34;
        # check if the faculty is already there or not
        if faculty not in self._mental_faculties:
            self._mental_faculties.append(faculty)
        else:
            raise Exception(f&#34;The mental faculty {faculty} is already present in the agent.&#34;)
        
        return self

    @transactional()
    @config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
    def act(
        self,
        until_done=True,
        n=None,
        return_actions=False,
        max_content_length=None,
    ):
        &#34;&#34;&#34;
        Acts in the environment and updates its internal cognitive state.
        Either acts until the agent is done and needs additional stimuli, or acts a fixed number of times,
        but not both.

        Args:
            until_done (bool): Whether to keep acting until the agent is done and needs additional stimuli.
            n (int): The number of actions to perform. Defaults to None.
            return_actions (bool): Whether to return the actions or not. Defaults to False.
        &#34;&#34;&#34;

        # either act until done or act a fixed number of times, but not both
        assert not (until_done and n is not None)
        if n is not None:
            assert n &lt; TinyPerson.MAX_ACTIONS_BEFORE_DONE

        contents = []

        # A separate function to run before each action, which is not meant to be repeated in case of errors.
        def aux_pre_act():
            # TODO maybe we don&#39;t need this at all anymore?
            #
            # A quick thought before the action. This seems to help with better model responses, perhaps because
            # it interleaves user with assistant messages.
            pass # self.think(&#34;I will now think, reflect and act a bit, and then issue DONE.&#34;)        

        # Aux function to perform exactly one action.
        # Occasionally, the model will return JSON missing important keys, so we just ask it to try again
        # Sometimes `content` contains EpisodicMemory&#39;s MEMORY_BLOCK_OMISSION_INFO message, which raises a TypeError on line 443
        @repeat_on_error(retries=5, exceptions=[KeyError, TypeError])
        def aux_act_once():
            # ensure we have the latest prompt (initial system message + selected messages from memory)
            self.reset_prompt()
            
            action, role, content, all_negative_feedbacks = self.action_generator.generate_next_action(self, self.current_messages)
            logger.debug(f&#34;{self.name}&#39;s action: {action}&#34;)

            # check the next action similarity, and if it is too similar, put a system warning instruction in memory too
            next_action_similarity = utils.next_action_jaccard_similarity(self, action)

            # we have a redundant repetition check here, because this an be computed quickly and is often very useful.
            if self.enable_basic_action_repetition_prevention and \
               (TinyPerson.MAX_ACTION_SIMILARITY is not None) and (next_action_similarity &gt; TinyPerson.MAX_ACTION_SIMILARITY):
                
                logger.warning(f&#34;[{self.name}] Action similarity is too high ({next_action_similarity}), replacing it with DONE.&#34;)

                # replace the action with a DONE
                action = {&#34;type&#34;: &#34;DONE&#34;, &#34;content&#34;: &#34;&#34;, &#34;target&#34;: &#34;&#34;}
                content[&#34;action&#34;] = action      
                content[&#34;cognitive_state&#34;] = {}

                self.store_in_memory({&#39;role&#39;: &#39;system&#39;, 
                                    &#39;content&#39;: \
                                        f&#34;&#34;&#34;
                                        # EXCESSIVE ACTION SIMILARITY WARNING

                                        You were about to generate a repetitive action (jaccard similarity = {next_action_similarity}).
                                        Thus, the action was discarded and replaced by an artificial DONE.

                                        DO NOT BE REPETITIVE. This is not a human-like behavior, therefore you **must** avoid this in the future.
                                        Your alternatives are:
                                        - produce more diverse actions.
                                        - aggregate similar actions into a single, larger, action and produce it all at once.
                                        - as a **last resort only**, you may simply not acting at all by issuing a DONE.

                                        
                                        &#34;&#34;&#34;,
                                    &#39;type&#39;: &#39;feedback&#39;,
                                    &#39;simulation_timestamp&#39;: self.iso_datetime()})

            # All checks done, we can commit the action to memory.
            self.store_in_memory({&#39;role&#39;: role, &#39;content&#39;: content, 
                                    &#39;type&#39;: &#39;action&#39;, 
                                    &#39;simulation_timestamp&#39;: self.iso_datetime()})
                
            self._actions_buffer.append(action)
            
            if &#34;cognitive_state&#34; in content:
                cognitive_state = content[&#34;cognitive_state&#34;]
                logger.debug(f&#34;[{self.name}] Cognitive state: {cognitive_state}&#34;)
                
                self._update_cognitive_state(goals=cognitive_state.get(&#34;goals&#34;, None),
                                             context=cognitive_state.get(&#34;context&#34;, None),
                                             attention=cognitive_state.get(&#34;emotions&#34;, None),
                                             emotions=cognitive_state.get(&#34;emotions&#34;, None))
            
            contents.append(content)          
            if TinyPerson.communication_display:
                self._display_communication(role=role, content=content, kind=&#39;action&#39;, simplified=True, max_content_length=max_content_length)
            
            #
            # Some actions induce an immediate stimulus or other side-effects. We need to process them here, by means of the mental faculties.
            #
            for faculty in self._mental_faculties:
                faculty.process_action(self, action)
            
            #
            # turns all_negative_feedbacks list into a system message
            #
            # TODO improve this?
            #
            ##if len(all_negative_feedbacks) &gt; 0:
            ##    feedback = &#34;&#34;&#34;
            ##    # QUALITY FEEDBACK
            ##
            ##    Up to the present moment, we monitored actions and tentative aborted actions (i.e., that were not actually executed), 
            ##    and some of them were not of good quality.
            ##    Some of those were replaced by regenerated actions of better quality. In the process of doing so, some
            ##    important quality feedback was produced, which is now given below.
            ##    
            ##    To improve your performance, and prevent future similar quality issues, you **MUST** take into account the following feedback
            ##    whenever computing your future actions. Note that the feedback might also include the actual action or tentative action
            ##    that was of low quality, so that you can understand what was wrong with it and avoid similar mistakes in the future.
            ##
            ##    &#34;&#34;&#34;
            ##    for i, feedback_item in enumerate(all_negative_feedbacks):
            ##        feedback += f&#34;{feedback_item}\n\n&#34;
            ##        feedback += f&#34;\n\n *** \n\n&#34;
            ##
            ##    self.store_in_memory({&#39;role&#39;: &#39;system&#39;, &#39;content&#39;: feedback, 
            ##                          &#39;type&#39;: &#39;feedback&#39;,
            ##                          &#39;simulation_timestamp&#39;: self.iso_datetime()})
            ##

            

            # count the actions as this can be useful for taking decisions later
            self.actions_count += 1             
            

        #
        # How to proceed with a sequence of actions.
        #

        ##### Option 1: run N actions ######
        if n is not None:
            for i in range(n):
                aux_pre_act()
                aux_act_once()

        ##### Option 2: run until DONE ######
        elif until_done:
            while (len(contents) == 0) or (
                not contents[-1][&#34;action&#34;][&#34;type&#34;] == &#34;DONE&#34;
            ):


                # check if the agent is acting without ever stopping
                if len(contents) &gt; TinyPerson.MAX_ACTIONS_BEFORE_DONE:
                    logger.warning(f&#34;[{self.name}] Agent {self.name} is acting without ever stopping. This may be a bug. Let&#39;s stop it here anyway.&#34;)
                    break
                if len(contents) &gt; 4: # just some minimum number of actions to check for repetition, could be anything &gt;= 3
                    # if the last three actions were the same, then we are probably in a loop
                    if contents[-1][&#39;action&#39;] == contents[-2][&#39;action&#39;] == contents[-3][&#39;action&#39;]:
                        logger.warning(f&#34;[{self.name}] Agent {self.name} is acting in a loop. This may be a bug. Let&#39;s stop it here anyway.&#34;)
                        break

                aux_pre_act()
                aux_act_once()

        # The end of a sequence of actions is always considered to mark the end of an episode.
        self.consolidate_episode_memories()

        if return_actions:
            return contents

    @transactional()
    @config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
    def listen(
        self,
        speech,
        source: AgentOrWorld = None,
        max_content_length=None,
    ):
        &#34;&#34;&#34;
        Listens to another agent (artificial or human) and updates its internal cognitive state.

        Args:
            speech (str): The speech to listen to.
            source (AgentOrWorld, optional): The source of the speech. Defaults to None.
        &#34;&#34;&#34;

        return self._observe(
            stimulus={
                &#34;type&#34;: &#34;CONVERSATION&#34;,
                &#34;content&#34;: speech,
                &#34;source&#34;: name_or_empty(source),
            },
            max_content_length=max_content_length,
        )

    @config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
    def socialize(
        self,
        social_description: str,
        source: AgentOrWorld = None,
        max_content_length=None,
    ):
        &#34;&#34;&#34;
        Perceives a social stimulus through a description and updates its internal cognitive state.

        Args:
            social_description (str): The description of the social stimulus.
            source (AgentOrWorld, optional): The source of the social stimulus. Defaults to None.
        &#34;&#34;&#34;
        return self._observe(
            stimulus={
                &#34;type&#34;: &#34;SOCIAL&#34;,
                &#34;content&#34;: social_description,
                &#34;source&#34;: name_or_empty(source),
            },
            max_content_length=max_content_length,
        )

    @config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
    def see(
        self,
        visual_description,
        source: AgentOrWorld = None,
        max_content_length=None,
    ):
        &#34;&#34;&#34;
        Perceives a visual stimulus through a description and updates its internal cognitive state.

        Args:
            visual_description (str): The description of the visual stimulus.
            source (AgentOrWorld, optional): The source of the visual stimulus. Defaults to None.
        &#34;&#34;&#34;
        return self._observe(
            stimulus={
                &#34;type&#34;: &#34;VISUAL&#34;,
                &#34;content&#34;: visual_description,
                &#34;source&#34;: name_or_empty(source),
            },
            max_content_length=max_content_length,
        )

    @config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
    def think(self, thought, max_content_length=None):
        &#34;&#34;&#34;
        Forces the agent to think about something and updates its internal cognitive state.

        &#34;&#34;&#34;
        return self._observe(
            stimulus={
                &#34;type&#34;: &#34;THOUGHT&#34;,
                &#34;content&#34;: thought,
                &#34;source&#34;: name_or_empty(self),
            },
            max_content_length=max_content_length,
        )

    @config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
    def internalize_goal(
        self, goal, max_content_length=None
    ):
        &#34;&#34;&#34;
        Internalizes a goal and updates its internal cognitive state.
        &#34;&#34;&#34;
        return self._observe(
            stimulus={
                &#34;type&#34;: &#34;INTERNAL_GOAL_FORMULATION&#34;,
                &#34;content&#34;: goal,
                &#34;source&#34;: name_or_empty(self),
            },
            max_content_length=max_content_length,
        )

    @transactional()
    @config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
    def _observe(self, stimulus, max_content_length=None):
        stimuli = [stimulus]

        content = {&#34;stimuli&#34;: stimuli}

        logger.debug(f&#34;[{self.name}] Observing stimuli: {content}&#34;)

        # whatever comes from the outside will be interpreted as coming from &#39;user&#39;, simply because
        # this is the counterpart of &#39;assistant&#39;

        self.store_in_memory({&#39;role&#39;: &#39;user&#39;, &#39;content&#39;: content, 
                              &#39;type&#39;: &#39;stimulus&#39;,
                              &#39;simulation_timestamp&#39;: self.iso_datetime()})

        if TinyPerson.communication_display:
            self._display_communication(
                role=&#34;user&#34;,
                content=content,
                kind=&#34;stimuli&#34;,
                simplified=True,
max_content_length=max_content_length,
            )
        
        # count the stimuli as this can be useful for taking decisions later
        self.stimuli_count += 1

        return self  # allows easier chaining of methods

    @transactional()
    def listen_and_act(
        self,
        speech,
        return_actions=False,
        max_content_length=None,
    ):
        &#34;&#34;&#34;
        Convenience method that combines the `listen` and `act` methods.
        &#34;&#34;&#34;

        self.listen(speech, max_content_length=max_content_length)
        return self.act(
            return_actions=return_actions, max_content_length=max_content_length
        )

    @transactional()
    @config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
    def see_and_act(
        self,
        visual_description,
        return_actions=False,
        max_content_length=None,
    ):
        &#34;&#34;&#34;
        Convenience method that combines the `see` and `act` methods.
        &#34;&#34;&#34;

        self.see(visual_description, max_content_length=max_content_length)
        return self.act(
            return_actions=return_actions, max_content_length=max_content_length
        )

    @transactional()
    @config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
    def think_and_act(
        self,
        thought,
        return_actions=False,
        max_content_length=None,
    ):
        &#34;&#34;&#34;
        Convenience method that combines the `think` and `act` methods.
        &#34;&#34;&#34;

        self.think(thought, max_content_length=max_content_length)
        return self.act(return_actions=return_actions, max_content_length=max_content_length)

    def read_documents_from_folder(self, documents_path:str):
        &#34;&#34;&#34;
        Reads documents from a directory and loads them into the semantic memory.
        &#34;&#34;&#34;
        logger.info(f&#34;Setting documents path to {documents_path} and loading documents.&#34;)

        self.semantic_memory.add_documents_path(documents_path)
    
    def read_document_from_file(self, file_path:str):
        &#34;&#34;&#34;
        Reads a document from a file and loads it into the semantic memory.
        &#34;&#34;&#34;
        logger.info(f&#34;Reading document from file: {file_path}&#34;)

        self.semantic_memory.add_document_path(file_path)
    
    def read_documents_from_web(self, web_urls:list):
        &#34;&#34;&#34;
        Reads documents from web URLs and loads them into the semantic memory.
        &#34;&#34;&#34;
        logger.info(f&#34;Reading documents from the following web URLs: {web_urls}&#34;)

        self.semantic_memory.add_web_urls(web_urls)
    
    def read_document_from_web(self, web_url:str):
        &#34;&#34;&#34;
        Reads a document from a web URL and loads it into the semantic memory.
        &#34;&#34;&#34;
        logger.info(f&#34;Reading document from web URL: {web_url}&#34;)

        self.semantic_memory.add_web_url(web_url)
    
    @transactional()
    def move_to(self, location, context=[]):
        &#34;&#34;&#34;
        Moves to a new location and updates its internal cognitive state.
        &#34;&#34;&#34;
        self._mental_state[&#34;location&#34;] = location

        # context must also be updated when moved, since we assume that context is dictated partly by location.
        self.change_context(context)

    @transactional()
    def change_context(self, context: list):
        &#34;&#34;&#34;
        Changes the context and updates its internal cognitive state.
        &#34;&#34;&#34;
        self._mental_state[&#34;context&#34;] = {
            &#34;description&#34;: item for item in context
        }

        self._update_cognitive_state(context=context)

    @transactional()
    def make_agent_accessible(
        self,
        agent: Self,
        relation_description: str = &#34;An agent I can currently interact with.&#34;,
    ):
        &#34;&#34;&#34;
        Makes an agent accessible to this agent.
        &#34;&#34;&#34;
        if agent not in self._accessible_agents:
            self._accessible_agents.append(agent)
            self._mental_state[&#34;accessible_agents&#34;].append(
                {&#34;name&#34;: agent.name, &#34;relation_description&#34;: relation_description}
            )
        else:
            logger.warning(
                f&#34;[{self.name}] Agent {agent.name} is already accessible to {self.name}.&#34;
            )
    @transactional()
    def make_agents_accessible(self, agents: list, relation_description: str = &#34;An agent I can currently interact with.&#34;):
        &#34;&#34;&#34;
        Makes a list of agents accessible to this agent.
        &#34;&#34;&#34;
        for agent in agents:
            self.make_agent_accessible(agent, relation_description)

    @transactional()
    def make_agent_inaccessible(self, agent: Self):
        &#34;&#34;&#34;
        Makes an agent inaccessible to this agent.
        &#34;&#34;&#34;
        if agent in self._accessible_agents:
            self._accessible_agents.remove(agent)
        else:
            logger.warning(
                f&#34;[{self.name}] Agent {agent.name} is already inaccessible to {self.name}.&#34;
            )

    @transactional()
    def make_all_agents_inaccessible(self):
        &#34;&#34;&#34;
        Makes all agents inaccessible to this agent.
        &#34;&#34;&#34;
        self._accessible_agents = []
        self._mental_state[&#34;accessible_agents&#34;] = []

    @property
    def accessible_agents(self):
        &#34;&#34;&#34;
        Property to access the list of accessible agents.
        &#34;&#34;&#34;
        return self._accessible_agents

    ###########################################################
    # Internal cognitive state changes
    ###########################################################
    @transactional()
    def _update_cognitive_state(
        self, goals=None, context=None, attention=None, emotions=None
    ):
        &#34;&#34;&#34;
        Update the TinyPerson&#39;s cognitive state.
        &#34;&#34;&#34;

        # Update current datetime. The passage of time is controlled by the environment, if any.
        if self.environment is not None and self.environment.current_datetime is not None:
            self._mental_state[&#34;datetime&#34;] = utils.pretty_datetime(self.environment.current_datetime)

        # update current goals
        if goals is not None:
            self._mental_state[&#34;goals&#34;] = goals

        # update current context
        if context is not None:
            self._mental_state[&#34;context&#34;] = context

        # update current attention
        if attention is not None:
            self._mental_state[&#34;attention&#34;] = attention

        # update current emotions
        if emotions is not None:
            self._mental_state[&#34;emotions&#34;] = emotions
        
        # update relevant memories for the current situation. These are memories that come to mind &#34;spontaneously&#34; when the agent is in a given context,
        # so avoiding the need to actively trying to remember them.
        current_memory_context = self.retrieve_relevant_memories_for_current_context()
        self._mental_state[&#34;memory_context&#34;] = current_memory_context

        self.reset_prompt()
        

    ###########################################################
    # Memory management
    ###########################################################

    def store_in_memory(self, value: Any) -&gt; list:
        self.episodic_memory.store(value)
        
        self._current_episode_event_count += 1
        logger.debug(f&#34;[{self.name}] Current episode event count: {self._current_episode_event_count}.&#34;)

        if self._current_episode_event_count &gt;= self.MAX_EPISODE_LENGTH:
            # commit the current episode to memory, if it is long enough
            logger.warning(f&#34;[{self.name}] Episode length exceeded {self.MAX_EPISODE_LENGTH} events. Committing episode to memory. Please check whether this was expected or not.&#34;)
            self.consolidate_episode_memories()
    
    def consolidate_episode_memories(self):
        &#34;&#34;&#34;
        Applies all memory consolidation or transformation processes appropriate to the conclusion of one simulation episode.
        &#34;&#34;&#34;
        # a minimum length of the episode is required to consolidate it, to avoid excessive fragments in the semantic memory
        if self._current_episode_event_count &gt; self.MIN_EPISODE_LENGTH:
            logger.debug(f&#34;[{self.name}] ***** Consolidating current episode memories into semantic memory *****&#34;)
        
            # Consolidate latest episodic memories into semantic memory
            if config_manager.get(&#34;enable_memory_consolidation&#34;):
                
                
                    episodic_consolidator = EpisodicConsolidator()
                    episode = self.episodic_memory.get_current_episode(item_types=[&#34;action&#34;, &#34;stimulus&#34;],)
                    logger.debug(f&#34;[{self.name}] Current episode: {episode}&#34;)
                    consolidated_memories = episodic_consolidator.process(episode, timestamp=self._mental_state[&#34;datetime&#34;], context=self._mental_state, persona=self.minibio())[&#34;consolidation&#34;]
                    if consolidated_memories is not None:
                        logger.info(f&#34;[{self.name}] Consolidating current {len(episode)} episodic events as consolidated semantic memories.&#34;)
                        logger.debug(f&#34;[{self.name}] Consolidated memories: {consolidated_memories}&#34;)
                        self.semantic_memory.store_all(consolidated_memories)
                    else:
                        logger.debug(f&#34;[{self.name}] No memories to consolidate from the current episode.&#34;)
                

            else:
                logger.warning(f&#34;[{self.name}] Memory consolidation is disabled. Not consolidating current episode memories into semantic memory.&#34;)

            # commit the current episode to episodic memory
            self.episodic_memory.commit_episode()
            self._current_episode_event_count = 0
            logger.debug(f&#34;[{self.name}] Current episode event count reset to 0 after consolidation.&#34;)

            # TODO reflections, optimizations, etc.

    def optimize_memory(self):
        pass #TODO

    def clear_episodic_memory(self, max_prefix_to_clear=None, max_suffix_to_clear=None):
        &#34;&#34;&#34;
        Clears the episodic memory, causing a permanent &#34;episodic amnesia&#34;. Note that this does not
        change other memories, such as semantic memory.  
        &#34;&#34;&#34;
        self.episodic_memory.clear(max_prefix_to_clear=max_prefix_to_clear, max_suffix_to_clear=max_suffix_to_clear)

    def retrieve_memories(self, first_n: int, last_n: int, include_omission_info:bool=True, max_content_length:int=None) -&gt; list:
        episodes = self.episodic_memory.retrieve(first_n=first_n, last_n=last_n, include_omission_info=include_omission_info)

        if max_content_length is not None:
            episodes = utils.truncate_actions_or_stimuli(episodes, max_content_length)

        return episodes


    def retrieve_recent_memories(self, max_content_length:int=None) -&gt; list:
        episodes = self.episodic_memory.retrieve_recent()

        if max_content_length is not None:
            episodes = utils.truncate_actions_or_stimuli(episodes, max_content_length)

        return episodes

    def retrieve_relevant_memories(self, relevance_target:str, top_k=20) -&gt; list:
        relevant = self.semantic_memory.retrieve_relevant(relevance_target, top_k=top_k)

        return relevant

    def retrieve_relevant_memories_for_current_context(self, top_k=7) -&gt; list:
        # current context is composed of th recent memories, plus context, goals, attention, and emotions
        context = self._mental_state[&#34;context&#34;]
        goals = self._mental_state[&#34;goals&#34;]
        attention = self._mental_state[&#34;attention&#34;]
        emotions = self._mental_state[&#34;emotions&#34;]
        recent_memories = &#34;\n&#34;.join([f&#34;  - {m[&#39;content&#39;]}&#34;  for m in self.retrieve_memories(first_n=10, last_n=20, max_content_length=500)])

        # put everything together in a nice markdown string to fetch relevant memories
        target = f&#34;&#34;&#34;
        Current Context: {context}
        Current Goals: {goals}
        Current Attention: {attention}
        Current Emotions: {emotions}
        Selected Episodic Memories (from oldest to newest):
        {recent_memories}
        &#34;&#34;&#34;

        logger.debug(f&#34;Retrieving relevant memories for contextual target: {target}&#34;)

        return self.retrieve_relevant_memories(target, top_k=top_k)

    def summarize_relevant_memories_via_full_scan(self, relevance_target:str, item_type: str = None) -&gt; str:
        &#34;&#34;&#34;
        Summarizes relevant memories for a given target by scanning the entire semantic memory.
        
        Args:
            relevance_target (str): The target to retrieve relevant memories for.
            item_type (str, optional): The type of items to summarize. Defaults to None.
            max_summary_length (int, optional): The maximum length of the summary. Defaults to 1000.
        
        Returns:
            str: The summary of relevant memories.
        &#34;&#34;&#34;
        return self.semantic_memory.summarize_relevant_via_full_scan(relevance_target, item_type=item_type)

    ###########################################################
    # Inspection conveniences
    ###########################################################

    def last_remembered_action(self, ignore_done:bool=True):
        &#34;&#34;&#34;
        Returns the last remembered action.

        Args:
            ignore_done (bool): Whether to ignore the &#34;DONE&#34; action or not. Defaults to True.
        &#34;&#34;&#34;
        action = None 
        
        memory_items_list = self.episodic_memory.retrieve_last(include_omission_info=False, item_type=&#34;action&#34;)

        if len(memory_items_list) &gt; 0:
            # iterate from last to first while the action type is not &#34;DONE&#34;
            for candidate_item in memory_items_list[::-1]:
                if candidate_item[&#34;content&#34;][&#34;action&#34;][&#34;type&#34;] != &#34;DONE&#34;:
                    action = candidate_item[&#34;content&#34;][&#34;action&#34;]
                    break
                else:
                    if ignore_done:
                        continue
                    else:
                        action = candidate_item[&#34;content&#34;][&#34;action&#34;]
                        break

        return action 


    ###########################################################
    # Communication display and action execution 
    ###########################################################

    def _display_communication(
        self,
        role,
        content,
        kind,
        simplified=True,
        max_content_length=default[&#34;max_content_display_length&#34;],
    ):
        &#34;&#34;&#34;
        Displays the current communication and stores it in a buffer for later use.
        &#34;&#34;&#34;
        # CONCURRENT PROTECTION, as we&#39;ll access shared display buffers
        with concurrent_agent_action_lock:
            if kind == &#34;stimuli&#34;:
                rendering = self._pretty_stimuli(
                    role=role,
                    content=content,
                    simplified=simplified,
                    max_content_length=max_content_length,
                )
                source = content[&#34;stimuli&#34;][0].get(&#34;source&#34;, None)
                target = self.name
                
            elif kind == &#34;action&#34;:
                rendering = self._pretty_action(
                    role=role,
                    content=content,
                    simplified=simplified,
                    max_content_length=max_content_length,
                )
                source = self.name
                target = content[&#34;action&#34;].get(&#34;target&#34;, None)

            else:
                raise ValueError(f&#34;Unknown communication kind: {kind}&#34;)

            # if the agent has no parent environment, then it is a free agent and we can display the communication.
            # otherwise, the environment will display the communication instead. This is important to make sure that
            # the communication is displayed in the correct order, since environments control the flow of their underlying
            # agents.
            if self.environment is None:
                self._push_and_display_latest_communication({&#34;kind&#34;: kind, &#34;rendering&#34;:rendering, &#34;content&#34;: content, &#34;source&#34;:source, &#34;target&#34;: target})
            else:
                self.environment._push_and_display_latest_communication({&#34;kind&#34;: kind, &#34;rendering&#34;:rendering, &#34;content&#34;: content, &#34;source&#34;:source, &#34;target&#34;: target})

    def _push_and_display_latest_communication(self, communication):
        &#34;&#34;&#34;
        Pushes the latest communications to the agent&#39;s buffer.
        &#34;&#34;&#34;
        self._displayed_communications_buffer.append(communication)
        print(communication[&#34;rendering&#34;])

    def pop_and_display_latest_communications(self):
        &#34;&#34;&#34;
        Pops the latest communications and displays them.
        &#34;&#34;&#34;
        communications = self._displayed_communications_buffer
        self._displayed_communications_buffer = []

        for communication in communications:
            print(communication[&#34;rendering&#34;])

        return communications

    def clear_communications_buffer(self):
        &#34;&#34;&#34;
        Cleans the communications buffer.
        &#34;&#34;&#34;
        self._displayed_communications_buffer = []

    @transactional()
    def pop_latest_actions(self) -&gt; list:
        &#34;&#34;&#34;
        Returns the latest actions performed by this agent. Typically used
        by an environment to consume the actions and provide the appropriate
        environmental semantics to them (i.e., effects on other agents).
        &#34;&#34;&#34;
        actions = self._actions_buffer
        self._actions_buffer = []
        return actions

    @transactional()
    def pop_actions_and_get_contents_for(
        self, action_type: str, only_last_action: bool = True
    ) -&gt; list:
        &#34;&#34;&#34;
        Returns the contents of actions of a given type performed by this agent.
        Typically used to perform inspections and tests.

        Args:
            action_type (str): The type of action to look for.
            only_last_action (bool, optional): Whether to only return the contents of the last action. Defaults to False.
        &#34;&#34;&#34;
        actions = self.pop_latest_actions()
        # Filter the actions by type
        actions = [action for action in actions if action[&#34;type&#34;] == action_type]

        # If interested only in the last action, return the latest one
        if only_last_action:
            return actions[-1].get(&#34;content&#34;, &#34;&#34;)

        # Otherwise, return all contents from the filtered actions
        return &#34;\n&#34;.join([action.get(&#34;content&#34;, &#34;&#34;) for action in actions])

    #############################################################################################
    # Formatting conveniences
    #
    # For rich colors,
    #    see: https://rich.readthedocs.io/en/latest/appendix/colors.html#appendix-colors
    #############################################################################################

    def __repr__(self):
        return f&#34;TinyPerson(name=&#39;{self.name}&#39;)&#34;

    @transactional()
    def minibio(self, extended=True, requirements=None):
        &#34;&#34;&#34;
        Returns a mini-biography of the TinyPerson.

        Args:
            extended (bool): Whether to include extended information or not.
            requirements (str): Additional requirements for the biography (e.g., focus on a specific aspect relevant for the scenario).

        Returns:
            str: The mini-biography.
        &#34;&#34;&#34;

        # if occupation is a dict and has a &#34;title&#34; key, use that as the occupation 
        if isinstance(self._persona[&#39;occupation&#39;], dict) and &#39;title&#39; in self._persona[&#39;occupation&#39;]:
            occupation = self._persona[&#39;occupation&#39;][&#39;title&#39;]
        else:
            occupation = self._persona[&#39;occupation&#39;]

        base_biography = f&#34;{self.name} is a {self._persona[&#39;age&#39;]} year old {occupation}, {self._persona[&#39;nationality&#39;]}, currently living in {self._persona[&#39;residence&#39;]}.&#34;

        if self._extended_agent_summary is None and extended:
            logger.debug(f&#34;Generating extended agent summary for {self.name}.&#34;)
            self._extended_agent_summary = LLMChat(
                                                system_prompt=f&#34;&#34;&#34;
                                                You are given a short biography of an agent, as well as a detailed specification of his or her other characteristics
                                                You must then produce a short paragraph (3 or 4 sentences) that **complements** the short biography, adding details about
                                                personality, interests, opinions, skills, etc. Do not repeat the information already given in the short biography.
                                                repeating the information already given. The paragraph should be coherent, consistent and comprehensive. All information
                                                must be grounded on the specification, **do not** create anything new.

                                                {&#34;Additional constraints: &#34;+ requirements if requirements is not None else &#34;&#34;}
                                                &#34;&#34;&#34;, 

                                                user_prompt=f&#34;&#34;&#34;
                                                **Short biography:** {base_biography}

                                                **Detailed specification:** {self._persona}
                                                &#34;&#34;&#34;).call()

        if extended:
            biography = f&#34;{base_biography} {self._extended_agent_summary}&#34;
        else:
            biography = base_biography

        return biography

    def pp_current_interactions(
        self,
        simplified=True,
        skip_system=True,
        max_content_length=default[&#34;max_content_display_length&#34;],
        first_n=None, 
        last_n=None, 
        include_omission_info:bool=True
    ):
        &#34;&#34;&#34;
        Pretty prints the current messages.
        &#34;&#34;&#34;
        print(
            self.pretty_current_interactions(
                simplified=simplified,
                skip_system=skip_system,
                max_content_length=max_content_length,
                first_n=first_n,
                last_n=last_n,
                include_omission_info=include_omission_info
            )
        )

    def pp_last_interactions(
        self,
        n=3,
        simplified=True,
        skip_system=True,
        max_content_length=default[&#34;max_content_display_length&#34;],
        include_omission_info:bool=True
    ):
        &#34;&#34;&#34;
        Pretty prints the last n messages. Useful to examine the conclusion of an experiment.
        &#34;&#34;&#34;
        print(
            self.pretty_current_interactions(
                simplified=simplified,
                skip_system=skip_system,
                max_content_length=max_content_length,
                first_n=None,
                last_n=n,
                include_omission_info=include_omission_info
            )
        )

    def pretty_current_interactions(self, simplified=True, skip_system=True, max_content_length=default[&#34;max_content_display_length&#34;], first_n=None, last_n=None, include_omission_info:bool=True):
      &#34;&#34;&#34;
      Returns a pretty, readable, string with the current messages.
      &#34;&#34;&#34;
      lines = [f&#34;**** BEGIN SIMULATION TRAJECTORY FOR {self.name} ****&#34;]
      last_step = 0
      for i, message in enumerate(self.episodic_memory.retrieve(first_n=first_n, last_n=last_n, include_omission_info=include_omission_info)):
        try:
            if not (skip_system and message[&#39;role&#39;] == &#39;system&#39;):
                msg_simplified_type = &#34;&#34;
                msg_simplified_content = &#34;&#34;
                msg_simplified_actor = &#34;&#34;

                last_step = i
                lines.append(f&#34;Agent simulation trajectory event #{i}:&#34;)
                lines.append(self._pretty_timestamp(message[&#39;role&#39;], message[&#39;simulation_timestamp&#39;]))

                if message[&#34;role&#34;] == &#34;system&#34;:
                    msg_simplified_actor = &#34;SYSTEM&#34;
                    msg_simplified_type = message[&#34;role&#34;]
                    msg_simplified_content = message[&#34;content&#34;]

                    lines.append(
                        f&#34;[dim] {msg_simplified_type}: {msg_simplified_content}[/]&#34;
                    )

                elif message[&#34;role&#34;] == &#34;user&#34;:
                    lines.append(
                        self._pretty_stimuli(
                            role=message[&#34;role&#34;],
                            content=message[&#34;content&#34;],
                            simplified=simplified,
                            max_content_length=max_content_length,
                        )
                    )

                elif message[&#34;role&#34;] == &#34;assistant&#34;:
                    lines.append(
                        self._pretty_action(
                            role=message[&#34;role&#34;],
                            content=message[&#34;content&#34;],
                            simplified=simplified,
                            max_content_length=max_content_length,
                        )
                    )
                else:
                    lines.append(f&#34;{message[&#39;role&#39;]}: {message[&#39;content&#39;]}&#34;)
        except:
            # print(f&#34;ERROR: {message}&#34;)
            continue

      lines.append(f&#34;The last agent simulation trajectory event number was {last_step}, thus the current number of the NEXT POTENTIAL TRAJECTORY EVENT is {last_step + 1}.&#34;)
      lines.append(f&#34;**** END SIMULATION TRAJECTORY FOR {self.name} ****\n\n&#34;)
      return &#34;\n&#34;.join(lines)

    def _pretty_stimuli(
        self,
        role,
        content,
        simplified=True,
        max_content_length=default[&#34;max_content_display_length&#34;],
    ) -&gt; list:
        &#34;&#34;&#34;
        Pretty prints stimuli.
        &#34;&#34;&#34;

        lines = []
        msg_simplified_actor = &#34;USER&#34;
        for stimus in content[&#34;stimuli&#34;]:
            if simplified:
                if stimus[&#34;source&#34;] != &#34;&#34;:
                    msg_simplified_actor = stimus[&#34;source&#34;]

                else:
                    msg_simplified_actor = &#34;USER&#34;

                msg_simplified_type = stimus[&#34;type&#34;]
                msg_simplified_content = utils.break_text_at_length(
                    stimus[&#34;content&#34;], max_length=max_content_length
                )

                indent = &#34; &#34; * len(msg_simplified_actor) + &#34;      &gt; &#34;
                msg_simplified_content = textwrap.fill(
                    msg_simplified_content,
                    width=TinyPerson.PP_TEXT_WIDTH,
                    initial_indent=indent,
                    subsequent_indent=indent,
                )

                #
                # Using rich for formatting. Let&#39;s make things as readable as possible!
                #

                rich_style = utils.RichTextStyle.get_style_for(&#34;stimulus&#34;, msg_simplified_type)
                lines.append(
                    f&#34;[{rich_style}][underline]{msg_simplified_actor}[/] --&gt; [{rich_style}][underline]{self.name}[/]: [{msg_simplified_type}] \n{msg_simplified_content}[/]&#34;
                )
            else:
                lines.append(f&#34;{role}: {content}&#34;)

        return &#34;\n&#34;.join(lines)

    def _pretty_action(
        self,
        role,
        content,
        simplified=True,
        max_content_length=default[&#34;max_content_display_length&#34;],
    ) -&gt; str:
        &#34;&#34;&#34;
        Pretty prints an action.
        &#34;&#34;&#34;
        if simplified:
            msg_simplified_actor = self.name
            msg_simplified_type = content[&#34;action&#34;][&#34;type&#34;]
            msg_simplified_content = utils.break_text_at_length(
                content[&#34;action&#34;].get(&#34;content&#34;, &#34;&#34;), max_length=max_content_length
            )

            indent = &#34; &#34; * len(msg_simplified_actor) + &#34;      &gt; &#34;
            msg_simplified_content = textwrap.fill(
                msg_simplified_content,
                width=TinyPerson.PP_TEXT_WIDTH,
                initial_indent=indent,
                subsequent_indent=indent,
            )

            #
            # Using rich for formatting. Let&#39;s make things as readable as possible!
            #
            rich_style = utils.RichTextStyle.get_style_for(&#34;action&#34;, msg_simplified_type)
            return f&#34;[{rich_style}][underline]{msg_simplified_actor}[/] acts: [{msg_simplified_type}] \n{msg_simplified_content}[/]&#34;
        
        else:
            return f&#34;{role}: {content}&#34;
    
    def _pretty_timestamp(
        self,
        role,
        timestamp,
    ) -&gt; str:
        &#34;&#34;&#34;
        Pretty prints a timestamp.
        &#34;&#34;&#34;
        return f&#34;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Date and time of events: {timestamp}&#34;

    def iso_datetime(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the current datetime of the environment, if any.

        Returns:
            datetime: The current datetime of the environment in ISO forat.
        &#34;&#34;&#34;
        if self.environment is not None and self.environment.current_datetime is not None:
            return self.environment.current_datetime.isoformat()
        else:
            return None

    ###########################################################
    # IO
    ###########################################################

    def save_specification(self, path, include_mental_faculties=True, include_memory=False, include_mental_state=False):
        &#34;&#34;&#34;
        Saves the current configuration to a JSON file.
        &#34;&#34;&#34;
        
        suppress_attributes = []

        # should we include the mental faculties?
        if not include_mental_faculties:
            suppress_attributes.append(&#34;_mental_faculties&#34;)

        # should we include the memory?
        if not include_memory:
            suppress_attributes.append(&#34;episodic_memory&#34;)
            suppress_attributes.append(&#34;semantic_memory&#34;)

        # should we include the mental state?
        if not include_mental_state:
            suppress_attributes.append(&#34;_mental_state&#34;)
        

        self.to_json(suppress=suppress_attributes, file_path=path,
                     serialization_type_field_name=&#34;type&#34;)

    
    @staticmethod
    def load_specification(path_or_dict, suppress_mental_faculties=False, suppress_memory=False, suppress_mental_state=False, 
                           auto_rename_agent=False, new_agent_name=None):
        &#34;&#34;&#34;
        Loads a JSON agent specification.

        Args:
            path_or_dict (str or dict): The path to the JSON file or the dictionary itself.
            suppress_mental_faculties (bool, optional): Whether to suppress loading the mental faculties. Defaults to False.
            suppress_memory (bool, optional): Whether to suppress loading the memory. Defaults to False.
            suppress_memory (bool, optional): Whether to suppress loading the memory. Defaults to False.
            suppress_mental_state (bool, optional): Whether to suppress loading the mental state. Defaults to False.
            auto_rename_agent (bool, optional): Whether to auto rename the agent. Defaults to False.
            new_agent_name (str, optional): The new name for the agent. Defaults to None.
        &#34;&#34;&#34;

        suppress_attributes = []

        # should we suppress the mental faculties?
        if suppress_mental_faculties:
            suppress_attributes.append(&#34;_mental_faculties&#34;)

        # should we suppress the memory?
        if suppress_memory:
            suppress_attributes.append(&#34;episodic_memory&#34;)
            suppress_attributes.append(&#34;semantic_memory&#34;)
        
        # should we suppress the mental state?
        if suppress_mental_state:
            suppress_attributes.append(&#34;_mental_state&#34;)

        return TinyPerson.from_json(json_dict_or_path=path_or_dict, suppress=suppress_attributes, 
                                    serialization_type_field_name=&#34;type&#34;,
                                    post_init_params={&#34;auto_rename_agent&#34;: auto_rename_agent, &#34;new_agent_name&#34;: new_agent_name})
    @staticmethod
    def load_specifications_from_folder(folder_path:str, file_suffix=&#34;.agent.json&#34;, suppress_mental_faculties=False, 
                                        suppress_memory=False, suppress_mental_state=False, auto_rename_agent=False, 
                                        new_agent_name=None) -&gt; list:
        &#34;&#34;&#34;     
        Loads all JSON agent specifications from a folder.

        Args:
            folder_path (str): The path to the folder containing the JSON files.
            file_suffix (str, optional): The suffix of the JSON files. Defaults to &#34;.agent.json&#34;.
            suppress_mental_faculties (bool, optional): Whether to suppress loading the mental faculties. Defaults to False.
            suppress_memory (bool, optional): Whether to suppress loading the memory. Defaults to False.
            suppress_mental_state (bool, optional): Whether to suppress loading the mental state. Defaults to False.
            auto_rename_agent (bool, optional): Whether to auto rename the agent. Defaults to False.
            new_agent_name (str, optional): The new name for the agent. Defaults to None.
        &#34;&#34;&#34;

        agents = []
        for file in os.listdir(folder_path):
            if file.endswith(file_suffix):
                file_path = os.path.join(folder_path, file)
                agent = TinyPerson.load_specification(file_path, suppress_mental_faculties=suppress_mental_faculties,
                                                      suppress_memory=suppress_memory, suppress_mental_state=suppress_mental_state,
                                                      auto_rename_agent=auto_rename_agent, new_agent_name=new_agent_name)
                agents.append(agent)

        return agents
        


    def encode_complete_state(self) -&gt; dict:
        &#34;&#34;&#34;
        Encodes the complete state of the TinyPerson, including the current messages, accessible agents, etc.
        This is meant for serialization and caching purposes, not for exporting the state to the user.
        &#34;&#34;&#34;
        to_copy = copy.copy(self.__dict__)

        # delete the logger and other attributes that cannot be serialized
        del to_copy[&#34;environment&#34;]
        del to_copy[&#34;_mental_faculties&#34;]
        del to_copy[&#34;action_generator&#34;]

        to_copy[&#34;_accessible_agents&#34;] = [agent.name for agent in self._accessible_agents]
        to_copy[&#39;episodic_memory&#39;] = self.episodic_memory.to_json()
        to_copy[&#39;semantic_memory&#39;] = self.semantic_memory.to_json()
        to_copy[&#34;_mental_faculties&#34;] = [faculty.to_json() for faculty in self._mental_faculties]

        state = copy.deepcopy(to_copy)

        return state

    def decode_complete_state(self, state: dict) -&gt; Self:
        &#34;&#34;&#34;
        Loads the complete state of the TinyPerson, including the current messages,
        and produces a new TinyPerson instance.
        &#34;&#34;&#34;
        state = copy.deepcopy(state)
        
        self._accessible_agents = [TinyPerson.get_agent_by_name(name) for name in state[&#34;_accessible_agents&#34;]]
        self.episodic_memory = EpisodicMemory.from_json(state[&#39;episodic_memory&#39;])
        self.semantic_memory = SemanticMemory.from_json(state[&#39;semantic_memory&#39;])
        
        for i, faculty in enumerate(self._mental_faculties):
            faculty = faculty.from_json(state[&#39;_mental_faculties&#39;][i])

        # delete fields already present in the state
        del state[&#34;_accessible_agents&#34;]
        del state[&#39;episodic_memory&#39;]
        del state[&#39;semantic_memory&#39;]
        del state[&#39;_mental_faculties&#39;]

        # restore other fields
        self.__dict__.update(state)


        return self
    
    def create_new_agent_from_current_spec(self, new_name:str) -&gt; Self:
        &#34;&#34;&#34;
        Creates a new agent from the current agent&#39;s specification. 

        Args:
            new_name (str): The name of the new agent. Agent names must be unique in the simulation, 
              this is why we need to provide a new name.
        &#34;&#34;&#34;
        new_agent = TinyPerson(name=new_name, spec_path=None)
        
        new_persona = copy.deepcopy(self._persona)
        new_persona[&#39;name&#39;] = new_name

        new_agent._persona = new_persona

        return new_agent
        

    @staticmethod
    def add_agent(agent):
        &#34;&#34;&#34;
        Adds an agent to the global list of agents. Agent names must be unique,
        so this method will raise an exception if the name is already in use.
        &#34;&#34;&#34;
        if agent.name in TinyPerson.all_agents:
            raise ValueError(f&#34;Agent name {agent.name} is already in use.&#34;)
        else:
            TinyPerson.all_agents[agent.name] = agent

    @staticmethod
    def has_agent(agent_name: str):
        &#34;&#34;&#34;
        Checks if an agent is already registered.
        &#34;&#34;&#34;
        return agent_name in TinyPerson.all_agents

    @staticmethod
    def set_simulation_for_free_agents(simulation):
        &#34;&#34;&#34;
        Sets the simulation if it is None. This allows free agents to be captured by specific simulation scopes
        if desired.
        &#34;&#34;&#34;
        for agent in TinyPerson.all_agents.values():
            if agent.simulation_id is None:
                simulation.add_agent(agent)

    @staticmethod
    def get_agent_by_name(name):
        &#34;&#34;&#34;
        Gets an agent by name.
        &#34;&#34;&#34;
        if name in TinyPerson.all_agents:
            return TinyPerson.all_agents[name]
        else:
            return None
    
    @staticmethod
    def all_agents_names():
        &#34;&#34;&#34;
        Returns the names of all agents.
        &#34;&#34;&#34;
        return list(TinyPerson.all_agents.keys())

    @staticmethod
    def clear_agents():
        &#34;&#34;&#34;
        Clears the global list of agents.
        &#34;&#34;&#34;
        TinyPerson.all_agents = {}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tinytroupe.utils.json.JsonSerializableRegistry" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry">JsonSerializableRegistry</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="tinytroupe.agent.TinyPerson.MAX_ACTIONS_BEFORE_DONE"><code class="name">var <span class="ident">MAX_ACTIONS_BEFORE_DONE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinytroupe.agent.TinyPerson.MAX_ACTION_SIMILARITY"><code class="name">var <span class="ident">MAX_ACTION_SIMILARITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinytroupe.agent.TinyPerson.MAX_EPISODE_LENGTH"><code class="name">var <span class="ident">MAX_EPISODE_LENGTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinytroupe.agent.TinyPerson.MIN_EPISODE_LENGTH"><code class="name">var <span class="ident">MIN_EPISODE_LENGTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinytroupe.agent.TinyPerson.PP_TEXT_WIDTH"><code class="name">var <span class="ident">PP_TEXT_WIDTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinytroupe.agent.TinyPerson.all_agents"><code class="name">var <span class="ident">all_agents</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinytroupe.agent.TinyPerson.communication_display"><code class="name">var <span class="ident">communication_display</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinytroupe.agent.TinyPerson.serializable_attributes"><code class="name">var <span class="ident">serializable_attributes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tinytroupe.agent.TinyPerson.serializable_attributes_renaming"><code class="name">var <span class="ident">serializable_attributes_renaming</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="tinytroupe.agent.TinyPerson.add_agent"><code class="name flex">
<span>def <span class="ident">add_agent</span></span>(<span>agent)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an agent to the global list of agents. Agent names must be unique,
so this method will raise an exception if the name is already in use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_agent(agent):
    &#34;&#34;&#34;
    Adds an agent to the global list of agents. Agent names must be unique,
    so this method will raise an exception if the name is already in use.
    &#34;&#34;&#34;
    if agent.name in TinyPerson.all_agents:
        raise ValueError(f&#34;Agent name {agent.name} is already in use.&#34;)
    else:
        TinyPerson.all_agents[agent.name] = agent</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.all_agents_names"><code class="name flex">
<span>def <span class="ident">all_agents_names</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the names of all agents.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def all_agents_names():
    &#34;&#34;&#34;
    Returns the names of all agents.
    &#34;&#34;&#34;
    return list(TinyPerson.all_agents.keys())</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.clear_agents"><code class="name flex">
<span>def <span class="ident">clear_agents</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the global list of agents.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def clear_agents():
    &#34;&#34;&#34;
    Clears the global list of agents.
    &#34;&#34;&#34;
    TinyPerson.all_agents = {}</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.get_agent_by_name"><code class="name flex">
<span>def <span class="ident">get_agent_by_name</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets an agent by name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_agent_by_name(name):
    &#34;&#34;&#34;
    Gets an agent by name.
    &#34;&#34;&#34;
    if name in TinyPerson.all_agents:
        return TinyPerson.all_agents[name]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.has_agent"><code class="name flex">
<span>def <span class="ident">has_agent</span></span>(<span>agent_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if an agent is already registered.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def has_agent(agent_name: str):
    &#34;&#34;&#34;
    Checks if an agent is already registered.
    &#34;&#34;&#34;
    return agent_name in TinyPerson.all_agents</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.load_specification"><code class="name flex">
<span>def <span class="ident">load_specification</span></span>(<span>path_or_dict, suppress_mental_faculties=False, suppress_memory=False, suppress_mental_state=False, auto_rename_agent=False, new_agent_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a JSON agent specification.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path_or_dict</code></strong> :&ensp;<code>str</code> or <code>dict</code></dt>
<dd>The path to the JSON file or the dictionary itself.</dd>
<dt><strong><code>suppress_mental_faculties</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to suppress loading the mental faculties. Defaults to False.</dd>
<dt><strong><code>suppress_memory</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to suppress loading the memory. Defaults to False.</dd>
<dt><strong><code>suppress_memory</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to suppress loading the memory. Defaults to False.</dd>
<dt><strong><code>suppress_mental_state</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to suppress loading the mental state. Defaults to False.</dd>
<dt><strong><code>auto_rename_agent</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to auto rename the agent. Defaults to False.</dd>
<dt><strong><code>new_agent_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The new name for the agent. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_specification(path_or_dict, suppress_mental_faculties=False, suppress_memory=False, suppress_mental_state=False, 
                       auto_rename_agent=False, new_agent_name=None):
    &#34;&#34;&#34;
    Loads a JSON agent specification.

    Args:
        path_or_dict (str or dict): The path to the JSON file or the dictionary itself.
        suppress_mental_faculties (bool, optional): Whether to suppress loading the mental faculties. Defaults to False.
        suppress_memory (bool, optional): Whether to suppress loading the memory. Defaults to False.
        suppress_memory (bool, optional): Whether to suppress loading the memory. Defaults to False.
        suppress_mental_state (bool, optional): Whether to suppress loading the mental state. Defaults to False.
        auto_rename_agent (bool, optional): Whether to auto rename the agent. Defaults to False.
        new_agent_name (str, optional): The new name for the agent. Defaults to None.
    &#34;&#34;&#34;

    suppress_attributes = []

    # should we suppress the mental faculties?
    if suppress_mental_faculties:
        suppress_attributes.append(&#34;_mental_faculties&#34;)

    # should we suppress the memory?
    if suppress_memory:
        suppress_attributes.append(&#34;episodic_memory&#34;)
        suppress_attributes.append(&#34;semantic_memory&#34;)
    
    # should we suppress the mental state?
    if suppress_mental_state:
        suppress_attributes.append(&#34;_mental_state&#34;)

    return TinyPerson.from_json(json_dict_or_path=path_or_dict, suppress=suppress_attributes, 
                                serialization_type_field_name=&#34;type&#34;,
                                post_init_params={&#34;auto_rename_agent&#34;: auto_rename_agent, &#34;new_agent_name&#34;: new_agent_name})</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.load_specifications_from_folder"><code class="name flex">
<span>def <span class="ident">load_specifications_from_folder</span></span>(<span>folder_path: str, file_suffix='.agent.json', suppress_mental_faculties=False, suppress_memory=False, suppress_mental_state=False, auto_rename_agent=False, new_agent_name=None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Loads all JSON agent specifications from a folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the folder containing the JSON files.</dd>
<dt><strong><code>file_suffix</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The suffix of the JSON files. Defaults to ".agent.json".</dd>
<dt><strong><code>suppress_mental_faculties</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to suppress loading the mental faculties. Defaults to False.</dd>
<dt><strong><code>suppress_memory</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to suppress loading the memory. Defaults to False.</dd>
<dt><strong><code>suppress_mental_state</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to suppress loading the mental state. Defaults to False.</dd>
<dt><strong><code>auto_rename_agent</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to auto rename the agent. Defaults to False.</dd>
<dt><strong><code>new_agent_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The new name for the agent. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_specifications_from_folder(folder_path:str, file_suffix=&#34;.agent.json&#34;, suppress_mental_faculties=False, 
                                    suppress_memory=False, suppress_mental_state=False, auto_rename_agent=False, 
                                    new_agent_name=None) -&gt; list:
    &#34;&#34;&#34;     
    Loads all JSON agent specifications from a folder.

    Args:
        folder_path (str): The path to the folder containing the JSON files.
        file_suffix (str, optional): The suffix of the JSON files. Defaults to &#34;.agent.json&#34;.
        suppress_mental_faculties (bool, optional): Whether to suppress loading the mental faculties. Defaults to False.
        suppress_memory (bool, optional): Whether to suppress loading the memory. Defaults to False.
        suppress_mental_state (bool, optional): Whether to suppress loading the mental state. Defaults to False.
        auto_rename_agent (bool, optional): Whether to auto rename the agent. Defaults to False.
        new_agent_name (str, optional): The new name for the agent. Defaults to None.
    &#34;&#34;&#34;

    agents = []
    for file in os.listdir(folder_path):
        if file.endswith(file_suffix):
            file_path = os.path.join(folder_path, file)
            agent = TinyPerson.load_specification(file_path, suppress_mental_faculties=suppress_mental_faculties,
                                                  suppress_memory=suppress_memory, suppress_mental_state=suppress_mental_state,
                                                  auto_rename_agent=auto_rename_agent, new_agent_name=new_agent_name)
            agents.append(agent)

    return agents</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.set_simulation_for_free_agents"><code class="name flex">
<span>def <span class="ident">set_simulation_for_free_agents</span></span>(<span>simulation)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the simulation if it is None. This allows free agents to be captured by specific simulation scopes
if desired.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_simulation_for_free_agents(simulation):
    &#34;&#34;&#34;
    Sets the simulation if it is None. This allows free agents to be captured by specific simulation scopes
    if desired.
    &#34;&#34;&#34;
    for agent in TinyPerson.all_agents.values():
        if agent.simulation_id is None:
            simulation.add_agent(agent)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tinytroupe.agent.TinyPerson.accessible_agents"><code class="name">var <span class="ident">accessible_agents</span></code></dt>
<dd>
<div class="desc"><p>Property to access the list of accessible agents.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def accessible_agents(self):
    &#34;&#34;&#34;
    Property to access the list of accessible agents.
    &#34;&#34;&#34;
    return self._accessible_agents</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tinytroupe.agent.TinyPerson.act"><code class="name flex">
<span>def <span class="ident">act</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.add_mental_faculties"><code class="name flex">
<span>def <span class="ident">add_mental_faculties</span></span>(<span>self, mental_faculties)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a list of mental faculties to the agent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_mental_faculties(self, mental_faculties):
    &#34;&#34;&#34;
    Adds a list of mental faculties to the agent.
    &#34;&#34;&#34;
    for faculty in mental_faculties:
        self.add_mental_faculty(faculty)
    
    return self</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.add_mental_faculty"><code class="name flex">
<span>def <span class="ident">add_mental_faculty</span></span>(<span>self, faculty)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a mental faculty to the agent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_mental_faculty(self, faculty):
    &#34;&#34;&#34;
    Adds a mental faculty to the agent.
    &#34;&#34;&#34;
    # check if the faculty is already there or not
    if faculty not in self._mental_faculties:
        self._mental_faculties.append(faculty)
    else:
        raise Exception(f&#34;The mental faculty {faculty} is already present in the agent.&#34;)
    
    return self</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.change_context"><code class="name flex">
<span>def <span class="ident">change_context</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.clear_communications_buffer"><code class="name flex">
<span>def <span class="ident">clear_communications_buffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cleans the communications buffer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_communications_buffer(self):
    &#34;&#34;&#34;
    Cleans the communications buffer.
    &#34;&#34;&#34;
    self._displayed_communications_buffer = []</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.clear_episodic_memory"><code class="name flex">
<span>def <span class="ident">clear_episodic_memory</span></span>(<span>self, max_prefix_to_clear=None, max_suffix_to_clear=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the episodic memory, causing a permanent "episodic amnesia". Note that this does not
change other memories, such as semantic memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_episodic_memory(self, max_prefix_to_clear=None, max_suffix_to_clear=None):
    &#34;&#34;&#34;
    Clears the episodic memory, causing a permanent &#34;episodic amnesia&#34;. Note that this does not
    change other memories, such as semantic memory.  
    &#34;&#34;&#34;
    self.episodic_memory.clear(max_prefix_to_clear=max_prefix_to_clear, max_suffix_to_clear=max_suffix_to_clear)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.clear_relationships"><code class="name flex">
<span>def <span class="ident">clear_relationships</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.consolidate_episode_memories"><code class="name flex">
<span>def <span class="ident">consolidate_episode_memories</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies all memory consolidation or transformation processes appropriate to the conclusion of one simulation episode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consolidate_episode_memories(self):
    &#34;&#34;&#34;
    Applies all memory consolidation or transformation processes appropriate to the conclusion of one simulation episode.
    &#34;&#34;&#34;
    # a minimum length of the episode is required to consolidate it, to avoid excessive fragments in the semantic memory
    if self._current_episode_event_count &gt; self.MIN_EPISODE_LENGTH:
        logger.debug(f&#34;[{self.name}] ***** Consolidating current episode memories into semantic memory *****&#34;)
    
        # Consolidate latest episodic memories into semantic memory
        if config_manager.get(&#34;enable_memory_consolidation&#34;):
            
            
                episodic_consolidator = EpisodicConsolidator()
                episode = self.episodic_memory.get_current_episode(item_types=[&#34;action&#34;, &#34;stimulus&#34;],)
                logger.debug(f&#34;[{self.name}] Current episode: {episode}&#34;)
                consolidated_memories = episodic_consolidator.process(episode, timestamp=self._mental_state[&#34;datetime&#34;], context=self._mental_state, persona=self.minibio())[&#34;consolidation&#34;]
                if consolidated_memories is not None:
                    logger.info(f&#34;[{self.name}] Consolidating current {len(episode)} episodic events as consolidated semantic memories.&#34;)
                    logger.debug(f&#34;[{self.name}] Consolidated memories: {consolidated_memories}&#34;)
                    self.semantic_memory.store_all(consolidated_memories)
                else:
                    logger.debug(f&#34;[{self.name}] No memories to consolidate from the current episode.&#34;)
            

        else:
            logger.warning(f&#34;[{self.name}] Memory consolidation is disabled. Not consolidating current episode memories into semantic memory.&#34;)

        # commit the current episode to episodic memory
        self.episodic_memory.commit_episode()
        self._current_episode_event_count = 0
        logger.debug(f&#34;[{self.name}] Current episode event count reset to 0 after consolidation.&#34;)

        # TODO reflections, optimizations, etc.</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.create_new_agent_from_current_spec"><code class="name flex">
<span>def <span class="ident">create_new_agent_from_current_spec</span></span>(<span>self, new_name: str) ‑> ~Self</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new agent from the current agent's specification. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the new agent. Agent names must be unique in the simulation,
this is why we need to provide a new name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_new_agent_from_current_spec(self, new_name:str) -&gt; Self:
    &#34;&#34;&#34;
    Creates a new agent from the current agent&#39;s specification. 

    Args:
        new_name (str): The name of the new agent. Agent names must be unique in the simulation, 
          this is why we need to provide a new name.
    &#34;&#34;&#34;
    new_agent = TinyPerson(name=new_name, spec_path=None)
    
    new_persona = copy.deepcopy(self._persona)
    new_persona[&#39;name&#39;] = new_name

    new_agent._persona = new_persona

    return new_agent</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.decode_complete_state"><code class="name flex">
<span>def <span class="ident">decode_complete_state</span></span>(<span>self, state: dict) ‑> ~Self</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the complete state of the TinyPerson, including the current messages,
and produces a new TinyPerson instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_complete_state(self, state: dict) -&gt; Self:
    &#34;&#34;&#34;
    Loads the complete state of the TinyPerson, including the current messages,
    and produces a new TinyPerson instance.
    &#34;&#34;&#34;
    state = copy.deepcopy(state)
    
    self._accessible_agents = [TinyPerson.get_agent_by_name(name) for name in state[&#34;_accessible_agents&#34;]]
    self.episodic_memory = EpisodicMemory.from_json(state[&#39;episodic_memory&#39;])
    self.semantic_memory = SemanticMemory.from_json(state[&#39;semantic_memory&#39;])
    
    for i, faculty in enumerate(self._mental_faculties):
        faculty = faculty.from_json(state[&#39;_mental_faculties&#39;][i])

    # delete fields already present in the state
    del state[&#34;_accessible_agents&#34;]
    del state[&#39;episodic_memory&#39;]
    del state[&#39;semantic_memory&#39;]
    del state[&#39;_mental_faculties&#39;]

    # restore other fields
    self.__dict__.update(state)


    return self</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.define"><code class="name flex">
<span>def <span class="ident">define</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.define_relationships"><code class="name flex">
<span>def <span class="ident">define_relationships</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.encode_complete_state"><code class="name flex">
<span>def <span class="ident">encode_complete_state</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the complete state of the TinyPerson, including the current messages, accessible agents, etc.
This is meant for serialization and caching purposes, not for exporting the state to the user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_complete_state(self) -&gt; dict:
    &#34;&#34;&#34;
    Encodes the complete state of the TinyPerson, including the current messages, accessible agents, etc.
    This is meant for serialization and caching purposes, not for exporting the state to the user.
    &#34;&#34;&#34;
    to_copy = copy.copy(self.__dict__)

    # delete the logger and other attributes that cannot be serialized
    del to_copy[&#34;environment&#34;]
    del to_copy[&#34;_mental_faculties&#34;]
    del to_copy[&#34;action_generator&#34;]

    to_copy[&#34;_accessible_agents&#34;] = [agent.name for agent in self._accessible_agents]
    to_copy[&#39;episodic_memory&#39;] = self.episodic_memory.to_json()
    to_copy[&#39;semantic_memory&#39;] = self.semantic_memory.to_json()
    to_copy[&#34;_mental_faculties&#34;] = [faculty.to_json() for faculty in self._mental_faculties]

    state = copy.deepcopy(to_copy)

    return state</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.generate_agent_system_prompt"><code class="name flex">
<span>def <span class="ident">generate_agent_system_prompt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_agent_system_prompt(self):
    with open(self._prompt_template_path, &#34;r&#34;) as f:
        agent_prompt_template = f.read()

    # let&#39;s operate on top of a copy of the configuration, because we&#39;ll need to add more variables, etc.
    template_variables = self._persona.copy()    
    template_variables[&#34;persona&#34;] = json.dumps(self._persona.copy(), indent=4)    

    # add mental state to the template variables
    template_variables[&#34;mental_state&#34;] = json.dumps(self._mental_state, indent=4)

    # Prepare additional action definitions and constraints
    actions_definitions_prompt = &#34;&#34;
    actions_constraints_prompt = &#34;&#34;
    for faculty in self._mental_faculties:
        actions_definitions_prompt += f&#34;{faculty.actions_definitions_prompt()}\n&#34;
        actions_constraints_prompt += f&#34;{faculty.actions_constraints_prompt()}\n&#34;
    
    # Make the additional prompt pieces available to the template. 
    # Identation here is to align with the text structure in the template.
    template_variables[&#39;actions_definitions_prompt&#39;] = textwrap.indent(actions_definitions_prompt.strip(), &#34;  &#34;)
    template_variables[&#39;actions_constraints_prompt&#39;] = textwrap.indent(actions_constraints_prompt.strip(), &#34;  &#34;)

    # RAI prompt components, if requested
    template_variables = utils.add_rai_template_variables_if_enabled(template_variables)

    return chevron.render(agent_prompt_template, template_variables)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value of a key in the TinyPerson's persona configuration.
Supports dot notation for nested keys (e.g., "address.city").</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, key):
    &#34;&#34;&#34;
    Returns the value of a key in the TinyPerson&#39;s persona configuration.
    Supports dot notation for nested keys (e.g., &#34;address.city&#34;).
    &#34;&#34;&#34;
    keys = key.split(&#34;.&#34;)
    value = self._persona
    for k in keys:
        if isinstance(value, dict):
            value = value.get(k, None)
        else:
            return None  # If the path is invalid, return None
    return value</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.import_fragment"><code class="name flex">
<span>def <span class="ident">import_fragment</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.include_persona_definitions"><code class="name flex">
<span>def <span class="ident">include_persona_definitions</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.internalize_goal"><code class="name flex">
<span>def <span class="ident">internalize_goal</span></span>(<span>self, goal, max_content_length=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Internalizes a goal and updates its internal cognitive state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
def internalize_goal(
    self, goal, max_content_length=None
):
    &#34;&#34;&#34;
    Internalizes a goal and updates its internal cognitive state.
    &#34;&#34;&#34;
    return self._observe(
        stimulus={
            &#34;type&#34;: &#34;INTERNAL_GOAL_FORMULATION&#34;,
            &#34;content&#34;: goal,
            &#34;source&#34;: name_or_empty(self),
        },
        max_content_length=max_content_length,
    )</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.iso_datetime"><code class="name flex">
<span>def <span class="ident">iso_datetime</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current datetime of the environment, if any.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime</code></dt>
<dd>The current datetime of the environment in ISO forat.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iso_datetime(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the current datetime of the environment, if any.

    Returns:
        datetime: The current datetime of the environment in ISO forat.
    &#34;&#34;&#34;
    if self.environment is not None and self.environment.current_datetime is not None:
        return self.environment.current_datetime.isoformat()
    else:
        return None</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.last_remembered_action"><code class="name flex">
<span>def <span class="ident">last_remembered_action</span></span>(<span>self, ignore_done: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the last remembered action.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ignore_done</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to ignore the "DONE" action or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last_remembered_action(self, ignore_done:bool=True):
    &#34;&#34;&#34;
    Returns the last remembered action.

    Args:
        ignore_done (bool): Whether to ignore the &#34;DONE&#34; action or not. Defaults to True.
    &#34;&#34;&#34;
    action = None 
    
    memory_items_list = self.episodic_memory.retrieve_last(include_omission_info=False, item_type=&#34;action&#34;)

    if len(memory_items_list) &gt; 0:
        # iterate from last to first while the action type is not &#34;DONE&#34;
        for candidate_item in memory_items_list[::-1]:
            if candidate_item[&#34;content&#34;][&#34;action&#34;][&#34;type&#34;] != &#34;DONE&#34;:
                action = candidate_item[&#34;content&#34;][&#34;action&#34;]
                break
            else:
                if ignore_done:
                    continue
                else:
                    action = candidate_item[&#34;content&#34;][&#34;action&#34;]
                    break

    return action </code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.listen"><code class="name flex">
<span>def <span class="ident">listen</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.listen_and_act"><code class="name flex">
<span>def <span class="ident">listen_and_act</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.make_agent_accessible"><code class="name flex">
<span>def <span class="ident">make_agent_accessible</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.make_agent_inaccessible"><code class="name flex">
<span>def <span class="ident">make_agent_inaccessible</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.make_agents_accessible"><code class="name flex">
<span>def <span class="ident">make_agents_accessible</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.make_all_agents_inaccessible"><code class="name flex">
<span>def <span class="ident">make_all_agents_inaccessible</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.minibio"><code class="name flex">
<span>def <span class="ident">minibio</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.move_to"><code class="name flex">
<span>def <span class="ident">move_to</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.optimize_memory"><code class="name flex">
<span>def <span class="ident">optimize_memory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize_memory(self):
    pass #TODO</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.pop_actions_and_get_contents_for"><code class="name flex">
<span>def <span class="ident">pop_actions_and_get_contents_for</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.pop_and_display_latest_communications"><code class="name flex">
<span>def <span class="ident">pop_and_display_latest_communications</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pops the latest communications and displays them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_and_display_latest_communications(self):
    &#34;&#34;&#34;
    Pops the latest communications and displays them.
    &#34;&#34;&#34;
    communications = self._displayed_communications_buffer
    self._displayed_communications_buffer = []

    for communication in communications:
        print(communication[&#34;rendering&#34;])

    return communications</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.pop_latest_actions"><code class="name flex">
<span>def <span class="ident">pop_latest_actions</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.pp_current_interactions"><code class="name flex">
<span>def <span class="ident">pp_current_interactions</span></span>(<span>self, simplified=True, skip_system=True, max_content_length=4000, first_n=None, last_n=None, include_omission_info: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty prints the current messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pp_current_interactions(
    self,
    simplified=True,
    skip_system=True,
    max_content_length=default[&#34;max_content_display_length&#34;],
    first_n=None, 
    last_n=None, 
    include_omission_info:bool=True
):
    &#34;&#34;&#34;
    Pretty prints the current messages.
    &#34;&#34;&#34;
    print(
        self.pretty_current_interactions(
            simplified=simplified,
            skip_system=skip_system,
            max_content_length=max_content_length,
            first_n=first_n,
            last_n=last_n,
            include_omission_info=include_omission_info
        )
    )</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.pp_last_interactions"><code class="name flex">
<span>def <span class="ident">pp_last_interactions</span></span>(<span>self, n=3, simplified=True, skip_system=True, max_content_length=4000, include_omission_info: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty prints the last n messages. Useful to examine the conclusion of an experiment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pp_last_interactions(
    self,
    n=3,
    simplified=True,
    skip_system=True,
    max_content_length=default[&#34;max_content_display_length&#34;],
    include_omission_info:bool=True
):
    &#34;&#34;&#34;
    Pretty prints the last n messages. Useful to examine the conclusion of an experiment.
    &#34;&#34;&#34;
    print(
        self.pretty_current_interactions(
            simplified=simplified,
            skip_system=skip_system,
            max_content_length=max_content_length,
            first_n=None,
            last_n=n,
            include_omission_info=include_omission_info
        )
    )</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.pretty_current_interactions"><code class="name flex">
<span>def <span class="ident">pretty_current_interactions</span></span>(<span>self, simplified=True, skip_system=True, max_content_length=4000, first_n=None, last_n=None, include_omission_info: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a pretty, readable, string with the current messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_current_interactions(self, simplified=True, skip_system=True, max_content_length=default[&#34;max_content_display_length&#34;], first_n=None, last_n=None, include_omission_info:bool=True):
  &#34;&#34;&#34;
  Returns a pretty, readable, string with the current messages.
  &#34;&#34;&#34;
  lines = [f&#34;**** BEGIN SIMULATION TRAJECTORY FOR {self.name} ****&#34;]
  last_step = 0
  for i, message in enumerate(self.episodic_memory.retrieve(first_n=first_n, last_n=last_n, include_omission_info=include_omission_info)):
    try:
        if not (skip_system and message[&#39;role&#39;] == &#39;system&#39;):
            msg_simplified_type = &#34;&#34;
            msg_simplified_content = &#34;&#34;
            msg_simplified_actor = &#34;&#34;

            last_step = i
            lines.append(f&#34;Agent simulation trajectory event #{i}:&#34;)
            lines.append(self._pretty_timestamp(message[&#39;role&#39;], message[&#39;simulation_timestamp&#39;]))

            if message[&#34;role&#34;] == &#34;system&#34;:
                msg_simplified_actor = &#34;SYSTEM&#34;
                msg_simplified_type = message[&#34;role&#34;]
                msg_simplified_content = message[&#34;content&#34;]

                lines.append(
                    f&#34;[dim] {msg_simplified_type}: {msg_simplified_content}[/]&#34;
                )

            elif message[&#34;role&#34;] == &#34;user&#34;:
                lines.append(
                    self._pretty_stimuli(
                        role=message[&#34;role&#34;],
                        content=message[&#34;content&#34;],
                        simplified=simplified,
                        max_content_length=max_content_length,
                    )
                )

            elif message[&#34;role&#34;] == &#34;assistant&#34;:
                lines.append(
                    self._pretty_action(
                        role=message[&#34;role&#34;],
                        content=message[&#34;content&#34;],
                        simplified=simplified,
                        max_content_length=max_content_length,
                    )
                )
            else:
                lines.append(f&#34;{message[&#39;role&#39;]}: {message[&#39;content&#39;]}&#34;)
    except:
        # print(f&#34;ERROR: {message}&#34;)
        continue

  lines.append(f&#34;The last agent simulation trajectory event number was {last_step}, thus the current number of the NEXT POTENTIAL TRAJECTORY EVENT is {last_step + 1}.&#34;)
  lines.append(f&#34;**** END SIMULATION TRAJECTORY FOR {self.name} ****\n\n&#34;)
  return &#34;\n&#34;.join(lines)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.read_document_from_file"><code class="name flex">
<span>def <span class="ident">read_document_from_file</span></span>(<span>self, file_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a document from a file and loads it into the semantic memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_document_from_file(self, file_path:str):
    &#34;&#34;&#34;
    Reads a document from a file and loads it into the semantic memory.
    &#34;&#34;&#34;
    logger.info(f&#34;Reading document from file: {file_path}&#34;)

    self.semantic_memory.add_document_path(file_path)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.read_document_from_web"><code class="name flex">
<span>def <span class="ident">read_document_from_web</span></span>(<span>self, web_url: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a document from a web URL and loads it into the semantic memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_document_from_web(self, web_url:str):
    &#34;&#34;&#34;
    Reads a document from a web URL and loads it into the semantic memory.
    &#34;&#34;&#34;
    logger.info(f&#34;Reading document from web URL: {web_url}&#34;)

    self.semantic_memory.add_web_url(web_url)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.read_documents_from_folder"><code class="name flex">
<span>def <span class="ident">read_documents_from_folder</span></span>(<span>self, documents_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads documents from a directory and loads them into the semantic memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_documents_from_folder(self, documents_path:str):
    &#34;&#34;&#34;
    Reads documents from a directory and loads them into the semantic memory.
    &#34;&#34;&#34;
    logger.info(f&#34;Setting documents path to {documents_path} and loading documents.&#34;)

    self.semantic_memory.add_documents_path(documents_path)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.read_documents_from_web"><code class="name flex">
<span>def <span class="ident">read_documents_from_web</span></span>(<span>self, web_urls: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads documents from web URLs and loads them into the semantic memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_documents_from_web(self, web_urls:list):
    &#34;&#34;&#34;
    Reads documents from web URLs and loads them into the semantic memory.
    &#34;&#34;&#34;
    logger.info(f&#34;Reading documents from the following web URLs: {web_urls}&#34;)

    self.semantic_memory.add_web_urls(web_urls)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.related_to"><code class="name flex">
<span>def <span class="ident">related_to</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.reset_prompt"><code class="name flex">
<span>def <span class="ident">reset_prompt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_prompt(self):

    # render the template with the current configuration
    self._init_system_message = self.generate_agent_system_prompt()

    # - reset system message
    # - make it clear that the provided events are past events and have already had their effects
    self.current_messages = [
        {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: self._init_system_message},
        {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: &#34;The next messages refer to past interactions you had recently and are meant to help you contextualize your next actions. &#34;\
                                    + &#34;They are the most recent episodic memories you have, including stimuli and actions. &#34;\
                                    + &#34;Their effects already took place and led to your present cognitive state (described above), so you can use them in conjunction &#34;\
                                    + &#34;with your cognitive state to inform your next actions and perceptions. Please consider them and then proceed with your next actions right after. &#34;}
    ]

    # sets up the actual interaction messages to use for prompting
    self.current_messages += self.retrieve_recent_memories()</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.retrieve_memories"><code class="name flex">
<span>def <span class="ident">retrieve_memories</span></span>(<span>self, first_n: int, last_n: int, include_omission_info: bool = True, max_content_length: int = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_memories(self, first_n: int, last_n: int, include_omission_info:bool=True, max_content_length:int=None) -&gt; list:
    episodes = self.episodic_memory.retrieve(first_n=first_n, last_n=last_n, include_omission_info=include_omission_info)

    if max_content_length is not None:
        episodes = utils.truncate_actions_or_stimuli(episodes, max_content_length)

    return episodes</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.retrieve_recent_memories"><code class="name flex">
<span>def <span class="ident">retrieve_recent_memories</span></span>(<span>self, max_content_length: int = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_recent_memories(self, max_content_length:int=None) -&gt; list:
    episodes = self.episodic_memory.retrieve_recent()

    if max_content_length is not None:
        episodes = utils.truncate_actions_or_stimuli(episodes, max_content_length)

    return episodes</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.retrieve_relevant_memories"><code class="name flex">
<span>def <span class="ident">retrieve_relevant_memories</span></span>(<span>self, relevance_target: str, top_k=20) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_relevant_memories(self, relevance_target:str, top_k=20) -&gt; list:
    relevant = self.semantic_memory.retrieve_relevant(relevance_target, top_k=top_k)

    return relevant</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.retrieve_relevant_memories_for_current_context"><code class="name flex">
<span>def <span class="ident">retrieve_relevant_memories_for_current_context</span></span>(<span>self, top_k=7) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_relevant_memories_for_current_context(self, top_k=7) -&gt; list:
    # current context is composed of th recent memories, plus context, goals, attention, and emotions
    context = self._mental_state[&#34;context&#34;]
    goals = self._mental_state[&#34;goals&#34;]
    attention = self._mental_state[&#34;attention&#34;]
    emotions = self._mental_state[&#34;emotions&#34;]
    recent_memories = &#34;\n&#34;.join([f&#34;  - {m[&#39;content&#39;]}&#34;  for m in self.retrieve_memories(first_n=10, last_n=20, max_content_length=500)])

    # put everything together in a nice markdown string to fetch relevant memories
    target = f&#34;&#34;&#34;
    Current Context: {context}
    Current Goals: {goals}
    Current Attention: {attention}
    Current Emotions: {emotions}
    Selected Episodic Memories (from oldest to newest):
    {recent_memories}
    &#34;&#34;&#34;

    logger.debug(f&#34;Retrieving relevant memories for contextual target: {target}&#34;)

    return self.retrieve_relevant_memories(target, top_k=top_k)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.save_specification"><code class="name flex">
<span>def <span class="ident">save_specification</span></span>(<span>self, path, include_mental_faculties=True, include_memory=False, include_mental_state=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the current configuration to a JSON file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_specification(self, path, include_mental_faculties=True, include_memory=False, include_mental_state=False):
    &#34;&#34;&#34;
    Saves the current configuration to a JSON file.
    &#34;&#34;&#34;
    
    suppress_attributes = []

    # should we include the mental faculties?
    if not include_mental_faculties:
        suppress_attributes.append(&#34;_mental_faculties&#34;)

    # should we include the memory?
    if not include_memory:
        suppress_attributes.append(&#34;episodic_memory&#34;)
        suppress_attributes.append(&#34;semantic_memory&#34;)

    # should we include the mental state?
    if not include_mental_state:
        suppress_attributes.append(&#34;_mental_state&#34;)
    

    self.to_json(suppress=suppress_attributes, file_path=path,
                 serialization_type_field_name=&#34;type&#34;)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.see"><code class="name flex">
<span>def <span class="ident">see</span></span>(<span>self, visual_description, source: Union[~Self, ForwardRef('TinyWorld')] = None, max_content_length=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Perceives a visual stimulus through a description and updates its internal cognitive state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>visual_description</code></strong> :&ensp;<code>str</code></dt>
<dd>The description of the visual stimulus.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>AgentOrWorld</code>, optional</dt>
<dd>The source of the visual stimulus. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
def see(
    self,
    visual_description,
    source: AgentOrWorld = None,
    max_content_length=None,
):
    &#34;&#34;&#34;
    Perceives a visual stimulus through a description and updates its internal cognitive state.

    Args:
        visual_description (str): The description of the visual stimulus.
        source (AgentOrWorld, optional): The source of the visual stimulus. Defaults to None.
    &#34;&#34;&#34;
    return self._observe(
        stimulus={
            &#34;type&#34;: &#34;VISUAL&#34;,
            &#34;content&#34;: visual_description,
            &#34;source&#34;: name_or_empty(source),
        },
        max_content_length=max_content_length,
    )</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.see_and_act"><code class="name flex">
<span>def <span class="ident">see_and_act</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.socialize"><code class="name flex">
<span>def <span class="ident">socialize</span></span>(<span>self, social_description: str, source: Union[~Self, ForwardRef('TinyWorld')] = None, max_content_length=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Perceives a social stimulus through a description and updates its internal cognitive state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>social_description</code></strong> :&ensp;<code>str</code></dt>
<dd>The description of the social stimulus.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>AgentOrWorld</code>, optional</dt>
<dd>The source of the social stimulus. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
def socialize(
    self,
    social_description: str,
    source: AgentOrWorld = None,
    max_content_length=None,
):
    &#34;&#34;&#34;
    Perceives a social stimulus through a description and updates its internal cognitive state.

    Args:
        social_description (str): The description of the social stimulus.
        source (AgentOrWorld, optional): The source of the social stimulus. Defaults to None.
    &#34;&#34;&#34;
    return self._observe(
        stimulus={
            &#34;type&#34;: &#34;SOCIAL&#34;,
            &#34;content&#34;: social_description,
            &#34;source&#34;: name_or_empty(source),
        },
        max_content_length=max_content_length,
    )</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.store_in_memory"><code class="name flex">
<span>def <span class="ident">store_in_memory</span></span>(<span>self, value: Any) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_in_memory(self, value: Any) -&gt; list:
    self.episodic_memory.store(value)
    
    self._current_episode_event_count += 1
    logger.debug(f&#34;[{self.name}] Current episode event count: {self._current_episode_event_count}.&#34;)

    if self._current_episode_event_count &gt;= self.MAX_EPISODE_LENGTH:
        # commit the current episode to memory, if it is long enough
        logger.warning(f&#34;[{self.name}] Episode length exceeded {self.MAX_EPISODE_LENGTH} events. Committing episode to memory. Please check whether this was expected or not.&#34;)
        self.consolidate_episode_memories()</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.summarize_relevant_memories_via_full_scan"><code class="name flex">
<span>def <span class="ident">summarize_relevant_memories_via_full_scan</span></span>(<span>self, relevance_target: str, item_type: str = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Summarizes relevant memories for a given target by scanning the entire semantic memory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>relevance_target</code></strong> :&ensp;<code>str</code></dt>
<dd>The target to retrieve relevant memories for.</dd>
<dt><strong><code>item_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The type of items to summarize. Defaults to None.</dd>
<dt><strong><code>max_summary_length</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The maximum length of the summary. Defaults to 1000.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The summary of relevant memories.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize_relevant_memories_via_full_scan(self, relevance_target:str, item_type: str = None) -&gt; str:
    &#34;&#34;&#34;
    Summarizes relevant memories for a given target by scanning the entire semantic memory.
    
    Args:
        relevance_target (str): The target to retrieve relevant memories for.
        item_type (str, optional): The type of items to summarize. Defaults to None.
        max_summary_length (int, optional): The maximum length of the summary. Defaults to 1000.
    
    Returns:
        str: The summary of relevant memories.
    &#34;&#34;&#34;
    return self.semantic_memory.summarize_relevant_via_full_scan(relevance_target, item_type=item_type)</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.think"><code class="name flex">
<span>def <span class="ident">think</span></span>(<span>self, thought, max_content_length=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Forces the agent to think about something and updates its internal cognitive state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@config_manager.config_defaults(max_content_length=&#34;max_content_display_length&#34;)
def think(self, thought, max_content_length=None):
    &#34;&#34;&#34;
    Forces the agent to think about something and updates its internal cognitive state.

    &#34;&#34;&#34;
    return self._observe(
        stimulus={
            &#34;type&#34;: &#34;THOUGHT&#34;,
            &#34;content&#34;: thought,
            &#34;source&#34;: name_or_empty(self),
        },
        max_content_length=max_content_length,
    )</code></pre>
</details>
</dd>
<dt id="tinytroupe.agent.TinyPerson.think_and_act"><code class="name flex">
<span>def <span class="ident">think_and_act</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(*args, **kwargs):
    obj_under_transaction = args[0]
    simulation = current_simulation()
    obj_sim_id = obj_under_transaction.simulation_id if hasattr(obj_under_transaction, &#39;simulation_id&#39;) else None

    logger.debug(f&#34;-----------------------------------------&gt; Transaction: {func.__name__} with args {args[1:]} and kwargs {kwargs} under simulation {obj_sim_id}, parallel={parallel}.&#34;)
    
    parallel_id = str(threading.current_thread())
    
    transaction = Transaction(obj_under_transaction, simulation, func, *args, **kwargs)
    result = transaction.execute(begin_parallel=parallel, parallel_id=parallel_id)
    
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tinytroupe.utils.json.JsonSerializableRegistry" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry">JsonSerializableRegistry</a></b></code>:
<ul class="hlist">
<li><code><a title="tinytroupe.utils.json.JsonSerializableRegistry.from_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.from_json">from_json</a></code></li>
<li><code><a title="tinytroupe.utils.json.JsonSerializableRegistry.to_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tinytroupe.agent.TinyToolUse"><code class="flex name class">
<span>class <span class="ident">TinyToolUse</span></span>
<span>(</span><span>tools: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows the agent to use tools to accomplish tasks. Tool usage is one of the most important cognitive skills
humans and primates have as we know.</p>
<p>Initializes the mental faculty.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the mental faculty.</dd>
<dt><strong><code>requires_faculties</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of mental faculties that this faculty requires to function properly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TinyToolUse(TinyMentalFaculty):
    &#34;&#34;&#34;
    Allows the agent to use tools to accomplish tasks. Tool usage is one of the most important cognitive skills
    humans and primates have as we know.
    &#34;&#34;&#34;

    def __init__(self, tools:list) -&gt; None:
        super().__init__(&#34;Tool Use&#34;)
    
        self.tools = tools
    
    def process_action(self, agent, action: dict) -&gt; bool:
        for tool in self.tools:
            if tool.process_action(agent, action):
                return True
        
        return False
    
    def actions_definitions_prompt(self) -&gt; str:
        # each tool should provide its own actions definitions prompt
        prompt = &#34;&#34;
        for tool in self.tools:
            prompt += tool.actions_definitions_prompt()
        
        return prompt
    
    def actions_constraints_prompt(self) -&gt; str:
        # each tool should provide its own actions constraints prompt
        prompt = &#34;&#34;
        for tool in self.tools:
            prompt += tool.actions_constraints_prompt()
        
        return prompt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty">TinyMentalFaculty</a></li>
<li><a title="tinytroupe.utils.json.JsonSerializableRegistry" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry">JsonSerializableRegistry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty">TinyMentalFaculty</a></b></code>:
<ul class="hlist">
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_constraints_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_constraints_prompt">actions_constraints_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_definitions_prompt" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.actions_definitions_prompt">actions_definitions_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.from_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.from_json">from_json</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.process_action" href="mental_faculty.html#tinytroupe.agent.mental_faculty.TinyMentalFaculty.process_action">process_action</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty.TinyMentalFaculty.to_json" href="../utils/json.html#tinytroupe.utils.json.JsonSerializableRegistry.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tinytroupe" href="../index.html">tinytroupe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="tinytroupe.agent.action_generator" href="action_generator.html">tinytroupe.agent.action_generator</a></code></li>
<li><code><a title="tinytroupe.agent.grounding" href="grounding.html">tinytroupe.agent.grounding</a></code></li>
<li><code><a title="tinytroupe.agent.memory" href="memory.html">tinytroupe.agent.memory</a></code></li>
<li><code><a title="tinytroupe.agent.mental_faculty" href="mental_faculty.html">tinytroupe.agent.mental_faculty</a></code></li>
<li><code><a title="tinytroupe.agent.tiny_person" href="tiny_person.html">tinytroupe.agent.tiny_person</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tinytroupe.agent.CustomMentalFaculty" href="#tinytroupe.agent.CustomMentalFaculty">CustomMentalFaculty</a></code></h4>
<ul class="">
<li><code><a title="tinytroupe.agent.CustomMentalFaculty.add_action" href="#tinytroupe.agent.CustomMentalFaculty.add_action">add_action</a></code></li>
<li><code><a title="tinytroupe.agent.CustomMentalFaculty.add_action_constraint" href="#tinytroupe.agent.CustomMentalFaculty.add_action_constraint">add_action_constraint</a></code></li>
<li><code><a title="tinytroupe.agent.CustomMentalFaculty.add_actions" href="#tinytroupe.agent.CustomMentalFaculty.add_actions">add_actions</a></code></li>
<li><code><a title="tinytroupe.agent.CustomMentalFaculty.add_actions_constraints" href="#tinytroupe.agent.CustomMentalFaculty.add_actions_constraints">add_actions_constraints</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tinytroupe.agent.EpisodicConsolidator" href="#tinytroupe.agent.EpisodicConsolidator">EpisodicConsolidator</a></code></h4>
</li>
<li>
<h4><code><a title="tinytroupe.agent.EpisodicMemory" href="#tinytroupe.agent.EpisodicMemory">EpisodicMemory</a></code></h4>
<ul class="">
<li><code><a title="tinytroupe.agent.EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO" href="#tinytroupe.agent.EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO">MEMORY_BLOCK_OMISSION_INFO</a></code></li>
<li><code><a title="tinytroupe.agent.EpisodicMemory.clear" href="#tinytroupe.agent.EpisodicMemory.clear">clear</a></code></li>
<li><code><a title="tinytroupe.agent.EpisodicMemory.commit_episode" href="#tinytroupe.agent.EpisodicMemory.commit_episode">commit_episode</a></code></li>
<li><code><a title="tinytroupe.agent.EpisodicMemory.count" href="#tinytroupe.agent.EpisodicMemory.count">count</a></code></li>
<li><code><a title="tinytroupe.agent.EpisodicMemory.get_current_episode" href="#tinytroupe.agent.EpisodicMemory.get_current_episode">get_current_episode</a></code></li>
<li><code><a title="tinytroupe.agent.EpisodicMemory.retrieve_first" href="#tinytroupe.agent.EpisodicMemory.retrieve_first">retrieve_first</a></code></li>
<li><code><a title="tinytroupe.agent.EpisodicMemory.retrieve_last" href="#tinytroupe.agent.EpisodicMemory.retrieve_last">retrieve_last</a></code></li>
<li><code><a title="tinytroupe.agent.EpisodicMemory.retrieve_recent" href="#tinytroupe.agent.EpisodicMemory.retrieve_recent">retrieve_recent</a></code></li>
<li><code><a title="tinytroupe.agent.EpisodicMemory.retrieve_relevant" href="#tinytroupe.agent.EpisodicMemory.retrieve_relevant">retrieve_relevant</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tinytroupe.agent.FilesAndWebGroundingFaculty" href="#tinytroupe.agent.FilesAndWebGroundingFaculty">FilesAndWebGroundingFaculty</a></code></h4>
</li>
<li>
<h4><code><a title="tinytroupe.agent.RecallFaculty" href="#tinytroupe.agent.RecallFaculty">RecallFaculty</a></code></h4>
</li>
<li>
<h4><code><a title="tinytroupe.agent.ReflectionConsolidator" href="#tinytroupe.agent.ReflectionConsolidator">ReflectionConsolidator</a></code></h4>
</li>
<li>
<h4><code><a title="tinytroupe.agent.SemanticMemory" href="#tinytroupe.agent.SemanticMemory">SemanticMemory</a></code></h4>
<ul class="">
<li><code><a title="tinytroupe.agent.SemanticMemory.serializable_attributes" href="#tinytroupe.agent.SemanticMemory.serializable_attributes">serializable_attributes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tinytroupe.agent.TinyPerson" href="#tinytroupe.agent.TinyPerson">TinyPerson</a></code></h4>
<ul class="">
<li><code><a title="tinytroupe.agent.TinyPerson.MAX_ACTIONS_BEFORE_DONE" href="#tinytroupe.agent.TinyPerson.MAX_ACTIONS_BEFORE_DONE">MAX_ACTIONS_BEFORE_DONE</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.MAX_ACTION_SIMILARITY" href="#tinytroupe.agent.TinyPerson.MAX_ACTION_SIMILARITY">MAX_ACTION_SIMILARITY</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.MAX_EPISODE_LENGTH" href="#tinytroupe.agent.TinyPerson.MAX_EPISODE_LENGTH">MAX_EPISODE_LENGTH</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.MIN_EPISODE_LENGTH" href="#tinytroupe.agent.TinyPerson.MIN_EPISODE_LENGTH">MIN_EPISODE_LENGTH</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.PP_TEXT_WIDTH" href="#tinytroupe.agent.TinyPerson.PP_TEXT_WIDTH">PP_TEXT_WIDTH</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.accessible_agents" href="#tinytroupe.agent.TinyPerson.accessible_agents">accessible_agents</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.act" href="#tinytroupe.agent.TinyPerson.act">act</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.add_agent" href="#tinytroupe.agent.TinyPerson.add_agent">add_agent</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.add_mental_faculties" href="#tinytroupe.agent.TinyPerson.add_mental_faculties">add_mental_faculties</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.add_mental_faculty" href="#tinytroupe.agent.TinyPerson.add_mental_faculty">add_mental_faculty</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.all_agents" href="#tinytroupe.agent.TinyPerson.all_agents">all_agents</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.all_agents_names" href="#tinytroupe.agent.TinyPerson.all_agents_names">all_agents_names</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.change_context" href="#tinytroupe.agent.TinyPerson.change_context">change_context</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.clear_agents" href="#tinytroupe.agent.TinyPerson.clear_agents">clear_agents</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.clear_communications_buffer" href="#tinytroupe.agent.TinyPerson.clear_communications_buffer">clear_communications_buffer</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.clear_episodic_memory" href="#tinytroupe.agent.TinyPerson.clear_episodic_memory">clear_episodic_memory</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.clear_relationships" href="#tinytroupe.agent.TinyPerson.clear_relationships">clear_relationships</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.communication_display" href="#tinytroupe.agent.TinyPerson.communication_display">communication_display</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.consolidate_episode_memories" href="#tinytroupe.agent.TinyPerson.consolidate_episode_memories">consolidate_episode_memories</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.create_new_agent_from_current_spec" href="#tinytroupe.agent.TinyPerson.create_new_agent_from_current_spec">create_new_agent_from_current_spec</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.decode_complete_state" href="#tinytroupe.agent.TinyPerson.decode_complete_state">decode_complete_state</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.define" href="#tinytroupe.agent.TinyPerson.define">define</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.define_relationships" href="#tinytroupe.agent.TinyPerson.define_relationships">define_relationships</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.encode_complete_state" href="#tinytroupe.agent.TinyPerson.encode_complete_state">encode_complete_state</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.generate_agent_system_prompt" href="#tinytroupe.agent.TinyPerson.generate_agent_system_prompt">generate_agent_system_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.get" href="#tinytroupe.agent.TinyPerson.get">get</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.get_agent_by_name" href="#tinytroupe.agent.TinyPerson.get_agent_by_name">get_agent_by_name</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.has_agent" href="#tinytroupe.agent.TinyPerson.has_agent">has_agent</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.import_fragment" href="#tinytroupe.agent.TinyPerson.import_fragment">import_fragment</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.include_persona_definitions" href="#tinytroupe.agent.TinyPerson.include_persona_definitions">include_persona_definitions</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.internalize_goal" href="#tinytroupe.agent.TinyPerson.internalize_goal">internalize_goal</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.iso_datetime" href="#tinytroupe.agent.TinyPerson.iso_datetime">iso_datetime</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.last_remembered_action" href="#tinytroupe.agent.TinyPerson.last_remembered_action">last_remembered_action</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.listen" href="#tinytroupe.agent.TinyPerson.listen">listen</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.listen_and_act" href="#tinytroupe.agent.TinyPerson.listen_and_act">listen_and_act</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.load_specification" href="#tinytroupe.agent.TinyPerson.load_specification">load_specification</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.load_specifications_from_folder" href="#tinytroupe.agent.TinyPerson.load_specifications_from_folder">load_specifications_from_folder</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.make_agent_accessible" href="#tinytroupe.agent.TinyPerson.make_agent_accessible">make_agent_accessible</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.make_agent_inaccessible" href="#tinytroupe.agent.TinyPerson.make_agent_inaccessible">make_agent_inaccessible</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.make_agents_accessible" href="#tinytroupe.agent.TinyPerson.make_agents_accessible">make_agents_accessible</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.make_all_agents_inaccessible" href="#tinytroupe.agent.TinyPerson.make_all_agents_inaccessible">make_all_agents_inaccessible</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.minibio" href="#tinytroupe.agent.TinyPerson.minibio">minibio</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.move_to" href="#tinytroupe.agent.TinyPerson.move_to">move_to</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.optimize_memory" href="#tinytroupe.agent.TinyPerson.optimize_memory">optimize_memory</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.pop_actions_and_get_contents_for" href="#tinytroupe.agent.TinyPerson.pop_actions_and_get_contents_for">pop_actions_and_get_contents_for</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.pop_and_display_latest_communications" href="#tinytroupe.agent.TinyPerson.pop_and_display_latest_communications">pop_and_display_latest_communications</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.pop_latest_actions" href="#tinytroupe.agent.TinyPerson.pop_latest_actions">pop_latest_actions</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.pp_current_interactions" href="#tinytroupe.agent.TinyPerson.pp_current_interactions">pp_current_interactions</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.pp_last_interactions" href="#tinytroupe.agent.TinyPerson.pp_last_interactions">pp_last_interactions</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.pretty_current_interactions" href="#tinytroupe.agent.TinyPerson.pretty_current_interactions">pretty_current_interactions</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.read_document_from_file" href="#tinytroupe.agent.TinyPerson.read_document_from_file">read_document_from_file</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.read_document_from_web" href="#tinytroupe.agent.TinyPerson.read_document_from_web">read_document_from_web</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.read_documents_from_folder" href="#tinytroupe.agent.TinyPerson.read_documents_from_folder">read_documents_from_folder</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.read_documents_from_web" href="#tinytroupe.agent.TinyPerson.read_documents_from_web">read_documents_from_web</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.related_to" href="#tinytroupe.agent.TinyPerson.related_to">related_to</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.reset_prompt" href="#tinytroupe.agent.TinyPerson.reset_prompt">reset_prompt</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.retrieve_memories" href="#tinytroupe.agent.TinyPerson.retrieve_memories">retrieve_memories</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.retrieve_recent_memories" href="#tinytroupe.agent.TinyPerson.retrieve_recent_memories">retrieve_recent_memories</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.retrieve_relevant_memories" href="#tinytroupe.agent.TinyPerson.retrieve_relevant_memories">retrieve_relevant_memories</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.retrieve_relevant_memories_for_current_context" href="#tinytroupe.agent.TinyPerson.retrieve_relevant_memories_for_current_context">retrieve_relevant_memories_for_current_context</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.save_specification" href="#tinytroupe.agent.TinyPerson.save_specification">save_specification</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.see" href="#tinytroupe.agent.TinyPerson.see">see</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.see_and_act" href="#tinytroupe.agent.TinyPerson.see_and_act">see_and_act</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.serializable_attributes" href="#tinytroupe.agent.TinyPerson.serializable_attributes">serializable_attributes</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.serializable_attributes_renaming" href="#tinytroupe.agent.TinyPerson.serializable_attributes_renaming">serializable_attributes_renaming</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.set_simulation_for_free_agents" href="#tinytroupe.agent.TinyPerson.set_simulation_for_free_agents">set_simulation_for_free_agents</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.socialize" href="#tinytroupe.agent.TinyPerson.socialize">socialize</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.store_in_memory" href="#tinytroupe.agent.TinyPerson.store_in_memory">store_in_memory</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.summarize_relevant_memories_via_full_scan" href="#tinytroupe.agent.TinyPerson.summarize_relevant_memories_via_full_scan">summarize_relevant_memories_via_full_scan</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.think" href="#tinytroupe.agent.TinyPerson.think">think</a></code></li>
<li><code><a title="tinytroupe.agent.TinyPerson.think_and_act" href="#tinytroupe.agent.TinyPerson.think_and_act">think_and_act</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tinytroupe.agent.TinyToolUse" href="#tinytroupe.agent.TinyToolUse">TinyToolUse</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>